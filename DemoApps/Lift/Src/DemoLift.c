/**
 * @file DemoLift.c
 * @brief Lift demo
 *
 * @author Bridgetek
 *
 * @date 2019
 * 
 * MIT License
 *
 * Copyright (c) [2019] [Bridgetek Pte Ltd (BRTChip)]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
#include "Common.h"
#include "Platform.h"
#include "EVE_CoCmd.h"
#include "DemoLift.h"

static EVE_HalContext s_halContext;
static EVE_HalContext* s_pHalContext;
void DemoLift();

// ************************************ main loop ************************************
int main(int argc, char* argv[])
{
	s_pHalContext = &s_halContext;
	Gpu_Init(s_pHalContext);

	// read and store calibration setting
#if !defined(BT8XXEMU_PLATFORM) && GET_CALIBRATION == 1
	Esd_Calibrate(s_pHalContext);
	Calibration_Save(s_pHalContext);
#endif

	Flash_Init(s_pHalContext, TEST_DIR "/Flash/BT81X_Flash.bin", "BT81X_Flash.bin");
	EVE_Util_clearScreen(s_pHalContext);

	char* info[] =
	{ "Lift demo",
		"Support QVGA, WQVGA, WVGA",
		"EVE1/2/3/4",
		"WIN32, FT900, IDM2040 \n\n This demo has 2 design: Lanscape and Portrait"
	};

	while (TRUE) {
		WelcomeScreen(s_pHalContext, info);
		DemoLift();
		EVE_Util_clearScreen(s_pHalContext);
		EVE_Hal_close(s_pHalContext);
		EVE_Hal_release();

		/* Init HW Hal for next loop*/
		Gpu_Init(s_pHalContext);
#if !defined(BT8XXEMU_PLATFORM) && GET_CALIBRATION == 1
		Calibration_Restore(s_pHalContext);
#endif
	}
	return 0;
}

// ************************************ application ************************************
/** @note The font data contains 22 chinese characters, which is generated by fnt_cvt utility from SimFang true type font file of Windows*/
#define ORIENTATION_LANDSCAPE
//#define ORIENTATION_PORTRAIT

#define APP_MATIRX_PRECITION (1)
#define APP_MATRIX_GPU_PRECITION (256)
  /* Macros for lift application */
#define LIFTAPP_DIR_NONE (0)
#define LIFTAPP_DIR_DOWN (1)
#define LIFTAPP_DIR_UP (2)

#define APP_GRAPHICS_FLIP_RIGHT (1)
#define APP_GRAPHICS_FLIP_BOTTOM (2)
  /* Structure for lift demo implementation */
typedef struct S_LiftAppBallsLinear
{
	int16_t xOffset;
	int16_t yOffset;
	char8_t dx;
	char8_t dy;
}S_LiftAppBallsLinear_t;

/* Macros for lift application font */
#define LIFTAPPCHARRESIZEPRECISION (256)
#define LIFTAPPMAXCHARS (12)

/* Structure for lift application font */
typedef struct S_LiftAppFont
{
	uint32_t MaxWidth;
	uint32_t MaxHeight;
	uint32_t Stride;
	uint8_t Format;
	uint8_t Width[LIFTAPPMAXCHARS];
}S_LiftAppFont_t;

/* bitmap transformation matrix - tbd - change the below to fixed point arthematic */
typedef struct App_GraphicsMatrix
{
	float a;
	float b;
	float c;
	float d;
	float e;
	float f;
}App_GraphicsMatrix_t;
/* Transform functionality */
typedef struct App_PostProcess_Transform
{
	/* all the below units are in terms of 256 units - signed 8.8 format */
	/* a and d are used for scaling, c and f are used for offest position */
	int32_t Transforma;
	int32_t Transformb;
	int32_t Transformc;
	int32_t Transformd;
	int32_t Transforme;
	int32_t Transformf;
	/* Spectial effects, mirror effect,  */
	uint32_t SpecialEffect;
}App_PostProcess_Transform_t;

typedef struct S_LiftAppRate
{
	uint32_t IttrCount;//total number of counts since starting
	uint32_t CurrTime;//current time since starting
}S_LiftAppRate_t;

typedef struct S_LiftAppTrasParams
{
	int32_t FloorNumChangeRate;//change of floor number in terms of units
	int32_t ResizeRate;//resize rate which includes from org to resize and resize to orginal
	int32_t FloorNumStagnantRate;//Floor being stagnant in terms of units
	int32_t ResizeDimMin;//dimension of min resize in terms of 8 bits precision
	int32_t ResizeDimMax;//dimension of max resize in terms of 8 bits precision
	int16_t MaxFloorNum;//make sure 0 is not considered in this usecase
	int16_t MinFloorNum;//make sure 0 is not considered in this usecase
}S_LiftAppTrasParams_t;

/* context of lift application */
typedef struct S_LiftAppCtxt
{
	S_LiftAppTrasParams_t SLATransPrms;
	S_LiftAppRate_t SLARate;
	char8_t ArrowDir;//0 means no direction, 1 means going down, 2 means going up
	char8_t CurrFloorNum;//not more less than -128 and more than 127
	char8_t NextFloorNum;//Next floor number from this floor - need to handle same floor number also
	int32_t CurrFloorNumChangeRate;
	int32_t CurrFloorNumStagnantRate;
	int32_t CurrFloorNumResizeRate;
	int32_t CurrArrowResizeRate;
	char8_t AudioPlaying;
	char8_t Orientation;
}S_LiftAppCtxt_t;

uint32_t music_playing = 0, fileszsave = 0;

#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
FATFS FatFs;
int16_t xy = 0;
int32_t curr_rtc_clock;

typedef struct _localtime {
	WORD wYear;
	WORD wMonth;
	WORD wDayOfWeek;
	WORD wDay;
	WORD wHour;
	WORD wMinute;
	WORD wSecond;
	WORD wMilliseconds;
} _localtime;
_localtime st, lt;
DWORD get_fattime(void) {
	/* Returns current time packed into a DWORD variable */
	return 0;
}
#else
SYSTEMTIME st, lt;
#endif

#define STARTUP_ADDRESS	100*1024L

#ifdef FT81X_ENABLE
Gpu_Fonts_t g_Gpu_Fonts[] = {
	/* VC1 Hardware Fonts index 16*/
	{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	1,
	1,
	8,
	8,
	1047548 },
	/* VC1 Hardware Fonts index 17*/
	{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	1,
	1,
	8,
	8,
	1046524 },
	/* VC1 Hardware Fonts index 18*/
	{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	1,
	1,
	8,
	16,
	1044476 },
	/* VC1 Hardware Fonts index 19*/
	{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	1,
	1,
	8,
	16,
	1042428 },
	/* VC1 Hardware Fonts index 20*/
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 4, 6, 6, 9, 8, 2, 4, 4, 4, 6, 3, 4, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 3, 6, 5, 6, 6, 11, 7, 7, 8, 8, 7, 6, 8, 8, 3, 5, 7, 6, 9, 8, 8, 7, 8, 7, 7, 5, 8, 7, 9, 7, 7, 7, 3, 3, 3, 6, 6, 3, 5, 6, 5, 6, 5, 4, 6, 6, 2, 2, 5, 2, 8, 6, 6, 6, 6, 4, 5, 4, 5, 6, 8, 6, 5, 5, 3, 3, 3, 7, 0,
	1,
	2,
	10,
	13,
	1039100 },
	/* VC1 Hardware Fonts index 21*/
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 5, 8, 8, 12, 10, 3, 5, 5, 7, 9, 3, 4, 3, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 4, 8, 9, 8, 8, 13, 9, 9, 10, 10, 9, 8, 11, 10, 4, 7, 9, 8, 12, 10, 11, 9, 11, 10, 9, 9, 10, 9, 13, 9, 9, 9, 4, 4, 4, 7, 8, 5, 8, 7, 7, 8, 8, 4, 8, 8, 3, 3, 7, 3, 11, 8, 8, 8, 8, 5, 7, 4, 7, 7, 10, 7, 7, 7, 5, 3, 5, 8, 0,
	1,
	2,
	13,
	17,
	1035580 },
	/* VC1 Hardware Fonts index 22*/
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 6, 9, 9, 14, 11, 3, 6, 6, 6, 10, 4, 5, 4, 5, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 4, 4, 10, 10, 10, 9, 17, 11, 11, 12, 12, 11, 10, 13, 12, 4, 8, 11, 9, 13, 12, 13, 11, 13, 12, 11, 10, 12, 11, 15, 11, 11, 10, 5, 5, 5, 8, 9, 6, 9, 9, 8, 9, 9, 5, 9, 9, 3, 4, 8, 3, 14, 9, 9, 9, 9, 5, 8, 5, 9, 8, 12, 8, 8, 8, 6, 4, 6, 10, 0,
	1,
	2,
	14,
	20,
	1031548 },
	/* VC1 Hardware Fonts index 23*/
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 6, 5, 10, 10, 16, 13, 3, 6, 6, 7, 10, 5, 6, 5, 5, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 5, 5, 10, 11, 10, 10, 18, 13, 13, 14, 14, 13, 12, 15, 14, 6, 10, 13, 11, 16, 14, 15, 13, 15, 14, 13, 12, 14, 13, 18, 13, 13, 12, 5, 5, 5, 9, 11, 4, 11, 11, 10, 11, 10, 6, 11, 10, 4, 4, 9, 4, 16, 10, 11, 11, 11, 6, 9, 6, 10, 10, 14, 10, 10, 9, 6, 5, 6, 10, 0,
	1,
	3,
	17,
	22,
	1024380 },
	/* VC1 Hardware Fonts index 24*/
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 8, 14, 13, 22, 17, 6, 8, 8, 10, 14, 6, 8, 6, 7, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 6, 6, 15, 15, 15, 12, 25, 17, 17, 18, 18, 16, 14, 19, 18, 8, 13, 18, 14, 21, 18, 18, 16, 18, 17, 16, 16, 18, 17, 22, 17, 16, 15, 7, 7, 7, 12, 14, 7, 13, 14, 12, 14, 13, 8, 14, 13, 6, 6, 12, 6, 20, 14, 13, 14, 14, 9, 12, 8, 14, 13, 18, 12, 13, 12, 8, 6, 8, 14, 0,
	1,
	3,
	24,
	29,
	0x2F7E3C },
	/* VC1 Hardware Fonts index 25*/
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 12, 19, 18, 29, 22, 6, 11, 11, 13, 19, 9, 11, 9, 9, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 9, 9, 19, 19, 19, 18, 34, 22, 22, 24, 24, 22, 20, 25, 24, 9, 16, 22, 18, 27, 24, 25, 22, 26, 24, 22, 20, 24, 22, 31, 22, 22, 20, 9, 9, 9, 16, 18, 11, 18, 18, 16, 18, 18, 9, 18, 18, 7, 7, 16, 7, 27, 18, 18, 18, 18, 11, 16, 9, 18, 16, 23, 16, 16, 16, 11, 9, 11, 19, 0,
	1,
	4,
	30,
	38,
	998684 },
	/* VC1 Hardware Fonts index 26*/
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 9, 8, 10, 9, 3, 5, 5, 6, 8, 3, 6, 4, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 7, 8, 7, 7, 13, 9, 9, 9, 9, 8, 8, 9, 10, 4, 8, 9, 8, 12, 10, 10, 9, 10, 9, 9, 9, 9, 9, 12, 9, 9, 8, 4, 6, 4, 6, 7, 4, 8, 8, 7, 8, 7, 5, 8, 8, 4, 4, 8, 4, 12, 8, 8, 8, 8, 5, 7, 5, 8, 7, 11, 7, 7, 7, 5, 3, 5, 10, 3,
	2,
	6,
	12,
	16,
	991260 },
	/* VC1 Hardware Fonts index 27*/
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 6, 11, 10, 12, 11, 4, 6, 6, 7, 10, 4, 8, 5, 7, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 4, 4, 9, 10, 9, 8, 15, 11, 11, 11, 12, 9, 9, 12, 12, 5, 9, 11, 9, 15, 12, 12, 11, 12, 11, 10, 10, 12, 11, 15, 11, 11, 10, 5, 7, 5, 7, 8, 5, 9, 10, 9, 10, 9, 6, 10, 10, 4, 4, 9, 4, 15, 10, 10, 10, 10, 6, 9, 6, 10, 9, 13, 9, 9, 9, 6, 4, 6, 12, 4,
	2,
	8,
	16,
	20,
	973852 },
	/* VC1 Hardware Fonts index 28*/
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 6, 8, 13, 12, 15, 13, 5, 7, 7, 9, 12, 5, 9, 6, 9, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 5, 5, 11, 12, 11, 10, 19, 13, 13, 13, 14, 12, 12, 14, 15, 6, 12, 14, 12, 18, 15, 14, 13, 15, 13, 13, 13, 14, 14, 18, 13, 13, 13, 6, 9, 6, 9, 10, 7, 12, 12, 11, 12, 11, 8, 12, 12, 5, 5, 11, 5, 18, 12, 12, 12, 12, 7, 11, 7, 12, 11, 16, 11, 11, 11, 7, 5, 7, 14, 5,
	2,
	9,
	18,
	25,
	950172 },
	/* VC1 Hardware Fonts index 29*/
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 9, 15, 14, 18, 15, 5, 8, 8, 10, 14, 5, 11, 6, 10, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 6, 6, 12, 14, 13, 11, 21, 15, 15, 15, 16, 13, 13, 16, 17, 7, 13, 15, 13, 21, 17, 16, 15, 17, 15, 15, 14, 16, 15, 21, 15, 15, 14, 7, 10, 6, 10, 11, 8, 13, 14, 13, 14, 13, 9, 14, 14, 6, 6, 13, 6, 21, 14, 14, 14, 14, 8, 13, 8, 14, 12, 18, 12, 12, 12, 8, 6, 8, 16, 6,
	2,
	11,
	22,
	28,
	917948 },
	/* VC1 Hardware Fonts index 30*/
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 11, 19, 18, 23, 19, 7, 11, 10, 13, 18, 7, 14, 8, 13, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 8, 8, 16, 17, 16, 15, 28, 20, 20, 20, 21, 17, 17, 21, 22, 9, 17, 20, 17, 27, 22, 21, 20, 22, 20, 19, 19, 21, 20, 27, 20, 20, 19, 8, 13, 8, 13, 15, 10, 17, 18, 16, 18, 16, 11, 18, 18, 8, 8, 16, 8, 27, 18, 18, 18, 18, 11, 16, 10, 18, 16, 23, 16, 16, 16, 11, 8, 11, 21, 8,
	2,
	14,
	28,
	36,
	863292 },
	/* VC1 Hardware Fonts index 31*/
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 11, 15, 26, 24, 31, 26, 9, 14, 14, 18, 24, 9, 19, 11, 17, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 11, 11, 21, 24, 22, 20, 38, 27, 27, 27, 28, 23, 23, 28, 30, 12, 23, 27, 23, 36, 30, 29, 27, 29, 27, 26, 25, 28, 27, 36, 27, 27, 25, 11, 18, 11, 18, 20, 13, 23, 24, 22, 24, 22, 15, 24, 24, 11, 11, 22, 11, 37, 24, 24, 24, 24, 15, 22, 13, 24, 21, 32, 21, 21, 21, 14, 10, 14, 29, 10,
	2,
	18,
	36,
	49,
	766524 },
};

#else
Gpu_Fonts_t g_Gpu_Fonts[] = {
	/* VC1 Hardware Fonts index 16*/
	{ 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
	1,
	1,
	8,
	8,
	1047548 },
	/* VC1 Hardware Fonts index 17*/
	{ 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
	1,
	1,
	8,
	8,
	1046524 },
	/* VC1 Hardware Fonts index 18*/
	{ 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
	1,
	1,
	8,
	16,
	1044476 },
	/* VC1 Hardware Fonts index 19*/
	{ 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
	1,
	1,
	8,
	16,
	1042428 },
	/* VC1 Hardware Fonts index 20*/
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,4,6,6,9,8,2,4,4,4,6,3,4,3,3,6,6,6,6,6,6,6,6,6,6,3,3,6,5,6,6,11,7,7,8,8,7,6,8,8,3,5,7,6,9,8,8,7,8,7,7,5,8,7,9,7,7,7,3,3,3,6,6,3,5,6,5,6,5,4,6,6,2,2,5,2,8,6,6,6,6,4,5,4,5,6,8,6,5,5,3,3,3,7,0,
	1,
	2,
	10,
	13,
	1039100 },
	/* VC1 Hardware Fonts index 21*/
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,5,8,8,12,10,3,5,5,7,9,3,4,3,4,8,8,8,8,8,8,8,8,8,8,3,4,8,9,8,8,13,9,9,10,10,9,8,11,10,4,7,9,8,12,10,11,9,11,10,9,9,10,9,13,9,9,9,4,4,4,7,8,5,8,7,7,8,8,4,8,8,3,3,7,3,11,8,8,8,8,5,7,4,7,7,10,7,7,7,5,3,5,8,0,
	1,
	2,
	13,
	17,
	1035580 },
	/* VC1 Hardware Fonts index 22*/
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,6,9,9,14,11,3,6,6,6,10,4,5,4,5,9,9,9,9,9,9,9,9,9,9,4,4,10,10,10,9,17,11,11,12,12,11,10,13,12,4,8,11,9,13,12,13,11,13,12,11,10,12,11,15,11,11,10,5,5,5,8,9,6,9,9,8,9,9,5,9,9,3,4,8,3,14,9,9,9,9,5,8,5,9,8,12,8,8,8,6,4,6,10,0,
	1,
	2,
	14,
	20,
	1031548 },
	/* VC1 Hardware Fonts index 23*/
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,6,5,10,10,16,13,3,6,6,7,10,5,6,5,5,10,10,10,10,10,10,10,10,10,10,5,5,10,11,10,10,18,13,13,14,14,13,12,15,14,6,10,13,11,16,14,15,13,15,14,13,12,14,13,18,13,13,12,5,5,5,9,11,4,11,11,10,11,10,6,11,10,4,4,9,4,16,10,11,11,11,6,9,6,10,10,14,10,10,9,6,5,6,10,0,
	1,
	3,
	17,
	22,
	1024380 },
	/* VC1 Hardware Fonts index 24*/
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,8,14,13,22,17,6,8,8,10,14,6,8,6,7,13,13,13,13,13,13,13,13,13,13,6,6,15,15,15,12,25,17,17,18,18,16,14,19,18,8,13,18,14,21,18,18,16,18,17,16,16,18,17,22,17,16,15,7,7,7,12,14,7,13,14,12,14,13,8,14,13,6,6,12,6,20,14,13,14,14,9,12,8,14,13,18,12,13,12,8,6,8,14,0,
	1,
	3,
	24,
	29,
	1015356 },
	/* VC1 Hardware Fonts index 25*/
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,9,12,19,18,29,22,6,11,11,13,19,9,11,9,9,18,18,18,18,18,18,18,18,18,18,9,9,19,19,19,18,34,22,22,24,24,22,20,25,24,9,16,22,18,27,24,25,22,26,24,22,20,24,22,31,22,22,20,9,9,9,16,18,11,18,18,16,18,18,9,18,18,7,7,16,7,27,18,18,18,18,11,16,9,18,16,23,16,16,16,11,9,11,19,0,
	1,
	4,
	30,
	38,
	998684 },
	/* VC1 Hardware Fonts index 26*/
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,4,5,9,8,10,9,3,5,5,6,8,3,6,4,6,8,8,8,8,8,8,8,8,8,8,4,4,7,8,7,7,13,9,9,9,9,8,8,9,10,4,8,9,8,12,10,10,9,10,9,9,9,9,9,12,9,9,8,4,6,4,6,7,4,8,8,7,8,7,5,8,8,4,4,8,4,12,8,8,8,8,5,7,5,8,7,11,7,7,7,5,3,5,10,3,
	2,
	6,
	12,
	16,
	991260 },
	/* VC1 Hardware Fonts index 27*/
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,6,11,10,12,11,4,6,6,7,10,4,8,5,7,10,10,10,10,10,10,10,10,10,10,4,4,9,10,9,8,15,11,11,11,12,9,9,12,12,5,9,11,9,15,12,12,11,12,11,10,10,12,11,15,11,11,10,5,7,5,7,8,5,9,10,9,10,9,6,10,10,4,4,9,4,15,10,10,10,10,6,9,6,10,9,13,9,9,9,6,4,6,12,4,
	2,
	8,
	16,
	20,
	973852 },
	/* VC1 Hardware Fonts index 28*/
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,6,8,13,12,15,13,5,7,7,9,12,5,9,6,9,12,12,12,12,12,12,12,12,12,12,5,5,11,12,11,10,19,13,13,13,14,12,12,14,15,6,12,14,12,18,15,14,13,15,13,13,13,14,14,18,13,13,13,6,9,6,9,10,7,12,12,11,12,11,8,12,12,5,5,11,5,18,12,12,12,12,7,11,7,12,11,16,11,11,11,7,5,7,14,5,
	2,
	9,
	18,
	25,
	950172 },
	/* VC1 Hardware Fonts index 29*/
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,9,15,14,18,15,5,8,8,10,14,5,11,6,10,14,14,14,14,14,14,14,14,14,14,6,6,12,14,13,11,21,15,15,15,16,13,13,16,17,7,13,15,13,21,17,16,15,17,15,15,14,16,15,21,15,15,14,7,10,6,10,11,8,13,14,13,14,13,9,14,14,6,6,13,6,21,14,14,14,14,8,13,8,14,12,18,12,12,12,8,6,8,16,6,
	2,
	11,
	22,
	28,
	917948 },
	/* VC1 Hardware Fonts index 30*/
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,11,19,18,23,19,7,11,10,13,18,7,14,8,13,17,17,17,17,17,17,17,17,17,17,8,8,16,17,16,15,28,20,20,20,21,17,17,21,22,9,17,20,17,27,22,21,20,22,20,19,19,21,20,27,20,20,19,8,13,8,13,15,10,17,18,16,18,16,11,18,18,8,8,16,8,27,18,18,18,18,11,16,10,18,16,23,16,16,16,11,8,11,21,8,
	2,
	14,
	28,
	36,
	863292 },
	/* VC1 Hardware Fonts index 31*/
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,11,15,26,24,31,26,9,14,14,18,24,9,19,11,17,24,24,24,24,24,24,24,24,24,24,11,11,21,24,22,20,38,27,27,27,28,23,23,28,30,12,23,27,23,36,30,29,27,29,27,26,25,28,27,36,27,27,25,11,18,11,18,20,13,23,24,22,24,22,15,24,24,11,11,22,11,37,24,24,24,24,15,22,13,24,21,32,21,21,21,14,10,14,29,10,
	2,
	18,
	36,
	49,
	766524 },
};
#endif

float App_lerp(float t, float a, float b) {
	return (float)((1 - t) * a + t * b);
}
float App_hsajsjskskjsk_SmoothLerp(float t, float a, float b) {
	float lt = 3 * t * t - 2 * t * t * t;

	return App_lerp(lt, a, b);
}

/* APIs useful for bitmap postprocessing */
/** Identity transform matrix */
int16_t App_TrsMtrxLoadIdentity(App_GraphicsMatrix_t *pMatrix) {
	/* Load the identity matrix into the input pointer */
	pMatrix->a = 1 * APP_MATIRX_PRECITION;
	pMatrix->b = 0 * APP_MATIRX_PRECITION;
	pMatrix->c = 0 * APP_MATIRX_PRECITION;
	pMatrix->d = 0 * APP_MATIRX_PRECITION;
	pMatrix->e = 1 * APP_MATIRX_PRECITION;
	pMatrix->f = 0 * APP_MATIRX_PRECITION;
	return 0;
}
int16_t App_UpdateTrsMtrx(App_GraphicsMatrix_t *pMatrix, App_PostProcess_Transform_t *ptrnsmtrx) {
	/* perform the translation from float to FT800 specific transform units */
	ptrnsmtrx->Transforma = pMatrix->a*APP_MATRIX_GPU_PRECITION;
	ptrnsmtrx->Transformd = pMatrix->d*APP_MATRIX_GPU_PRECITION;
	ptrnsmtrx->Transformb = pMatrix->b*APP_MATRIX_GPU_PRECITION;
	ptrnsmtrx->Transforme = pMatrix->e*APP_MATRIX_GPU_PRECITION;
	ptrnsmtrx->Transformc = pMatrix->c*APP_MATRIX_GPU_PRECITION;
	ptrnsmtrx->Transformf = pMatrix->f*APP_MATRIX_GPU_PRECITION;

	return 0;
}

/** give out the translated values. */
int16_t App_TrsMtrxTranslate(App_GraphicsMatrix_t *pMatrix, float x, float y, float *pxres, float *pyres) {
	float a, b, c, d, e, f;

	/* matrix multiplication */
	a = pMatrix->a;	b = pMatrix->b;	c = pMatrix->c;	d = pMatrix->d;	e = pMatrix->e;	f = pMatrix->f;

	*pxres = x*a + y*b + c;
	*pyres = x*d + y*e + f;
	pMatrix->c = *pxres;
	pMatrix->f = *pyres;

	return 0;
}
/** 
 * @brief API for rotation of angle degree 
 * 
 * - using vc++ math library 
 * - if not then use array of sine tables to compule both sine and cosine \n
 * +ve degree for anti clock wise and -ve for clock wise
 * @note not checking the overflow cases 
 */
int16_t App_TrsMtrxRotate(App_GraphicsMatrix_t *pMatrix, int32_t th) {
	double pi = 3.1415926535;
	double angle = -th*pi / 180;
	App_GraphicsMatrix_t tempmtx, tempinput;

	tempinput.a = pMatrix->a;
	tempinput.b = pMatrix->b;
	tempinput.c = pMatrix->c;
	tempinput.d = pMatrix->d;
	tempinput.e = pMatrix->e;
	tempinput.f = pMatrix->f;

	App_TrsMtrxLoadIdentity(&tempmtx);
	tempmtx.a = cos(angle)*APP_MATIRX_PRECITION;
	tempmtx.b = sin(angle)*APP_MATIRX_PRECITION;
	tempmtx.d = -sin(angle)*APP_MATIRX_PRECITION;
	tempmtx.e = cos(angle)*APP_MATIRX_PRECITION;

	/* perform matrix multiplecation and store in the input */
	pMatrix->a = tempinput.a*tempmtx.a + tempinput.b*tempmtx.d;
	pMatrix->b = tempinput.a*tempmtx.b + tempinput.b*tempmtx.e;
	pMatrix->c = tempinput.a*tempmtx.c + tempinput.b*tempmtx.f + tempinput.c * 1;
	pMatrix->d = tempinput.d*tempmtx.a + tempinput.e*tempmtx.d;
	pMatrix->e = tempinput.d*tempmtx.b + tempinput.e*tempmtx.e;
	pMatrix->f = tempinput.d*tempmtx.c + tempinput.e*tempmtx.f + tempinput.f * 1;

	return 0;
}
/**
 * @brief Scaling done for x and y factors - from 1 to 255
 * 
 * Input units are in terms of 65536 
 */
int16_t App_TrsMtrxScale(App_GraphicsMatrix_t *pMatrix, float xfactor, float yfactor) {
	pMatrix->a /= xfactor;
	pMatrix->d /= xfactor;

	pMatrix->b /= yfactor;
	pMatrix->e /= yfactor;

	return 0;
}
/**
 * @brief flip the image
 *
 * - 1 for right flip, 2 for bottom flip 
 */
int16_t App_TrsMtrxFlip(App_GraphicsMatrix_t *pMatrix, int32_t Option) {
	/* need to verify both */
	if (APP_GRAPHICS_FLIP_RIGHT == (Option & APP_GRAPHICS_FLIP_RIGHT)) {
		pMatrix->a = -pMatrix->a;
		pMatrix->d = -pMatrix->d;
	}
	if (APP_GRAPHICS_FLIP_BOTTOM == (Option & APP_GRAPHICS_FLIP_BOTTOM)) {
		pMatrix->b = -pMatrix->b;
		pMatrix->e = -pMatrix->e;
	}

	return 0;
}
/**
 * Array used for custom fonts 
 */
S_LiftAppFont_t G_LiftAppFontArrayNumbers[1] =
{
	//font structure
	{
		/* Max Width */
		80,
		/* Max Height */
		156,
		/* Max Stride */
		80,
		/* format */
		L8,
		/* Each character width */
		80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
	}
};
S_LiftAppFont_t G_LiftAppFontArrayArrow[1] =
{	//arrow structure
	{
		/* Max Width */
		80,
		/* Max Height */
		85,
		/* Max Stride */
		80,
		/* format */
		L8,
		/* Each character width */
		80,
	}
};
/* rate is applied for all the below transitions */

/*
lift floor traversal
Lift floor stagnant
Arrow resize
Floor number resize - resize rate can be same for both arrow and digits
*/

/**
 * control of floor numbers being traversed
 * start from a particular fllor and end in the particular floor
 * @brief api for control path of the lift application
 */
int32_t LiftAppControlFlow() {
}

/** @brief API to compute the bitmap offset wrt input characters and scale
 * 
 * ResizeVal is in terms of 8 bits precision - ex 1 will be equal to 256 \n
 * xOffset and  yOffset are in terms of 4 bits precision - 1/16th pixel format and are the center of the display character \n
 * Even the FT800 display list is generated in this API
 */
int32_t LiftAppComputeBitmap(S_LiftAppFont_t *pLAFont, int32_t FloorNum, uint8_t TotalNumChar, int32_t ResizeVal, int16_t xOffset, int16_t yOffset) {
	/* compute the total number of digits in the input */
	uint8_t TotalChar = 1;
	int32_t TotHzSz, TotVtSz, FlNum, i, xoff, yoff;
	char8_t FontValArray[8];

	TotalChar = 1;
	FlNum = FloorNum;
	TotHzSz = pLAFont->MaxWidth;
	FontValArray[0] = '\0';//requirement from dec2ascii api

	Gpu_Hal_Dec2Ascii(FontValArray, FloorNum);
	TotalChar = strlen(FontValArray);
	if (0 != TotalNumChar) {
		TotalChar = TotalNumChar;
	}
	TotHzSz = (pLAFont->MaxWidth * 16 * ResizeVal) / LIFTAPPCHARRESIZEPRECISION;
	TotVtSz = (pLAFont->MaxHeight * 16 * ResizeVal) / LIFTAPPCHARRESIZEPRECISION;

	//change the x and y offset to center of the characters
	xoff = xOffset * 16 - TotHzSz*TotalChar / 2;
	yoff = yOffset * 16 - TotVtSz / 2;
	/* since resize value is same for both the sides the resize is same for all characters */
	for (i = 0; i < TotalChar; i++) {
		/* Calculation of cell number from  */
		if ('-' == FontValArray[i]) {
			EVE_Cmd_wr32(s_pHalContext, CELL(0));
		}
		else {
			EVE_Cmd_wr32(s_pHalContext, CELL(FontValArray[i] - '0' + 1));
		}
		EVE_Cmd_wr32(s_pHalContext, VERTEX2F(xoff, yoff));
		//increment the character after every ittiration
		xoff += TotHzSz;
	}
	return 0;
}
/** 
 * @brief API for colomn bitmap computation
 */
int32_t LiftAppComputeBitmapColomn(S_LiftAppFont_t *pLAFont, int32_t FloorNum, uint8_t TotalNumChar, int32_t ResizeVal, int16_t xOffset, int16_t yOffset) {
	/* compute the total number of digits in the input */
	uint8_t TotalChar = 1;
	int32_t TotHzSz, TotVtSz, FlNum, i, xoff, yoff;
	char8_t FontValArray[8];

	TotalChar = 1;
	FlNum = FloorNum;
	TotHzSz = pLAFont->MaxWidth;
	FontValArray[0] = '\0';//requirement from dec2ascii api

	Gpu_Hal_Dec2Ascii(FontValArray, FloorNum);
	TotalChar = strlen(FontValArray);
	if (0 != TotalNumChar) {
		TotalChar = TotalNumChar;
	}
	TotHzSz = (pLAFont->MaxWidth * 16 * ResizeVal) / LIFTAPPCHARRESIZEPRECISION;
	TotVtSz = (pLAFont->MaxHeight * 16 * ResizeVal) / LIFTAPPCHARRESIZEPRECISION;

	//change the x and y offset to center of the characters
	xoff = xOffset * 16 - TotHzSz / 2;
	yoff = yOffset * 16 - TotVtSz*TotalChar / 2;
	/* since resize value is same for both the sides the resize is same for all characters */
	for (i = 0; i < TotalChar; i++) {
		/* Calculation of cell number from  */
		if ('-' == FontValArray[i]) {
			EVE_Cmd_wr32(s_pHalContext, CELL(0));
		}
		else {
			EVE_Cmd_wr32(s_pHalContext, CELL(FontValArray[i] - '0' + 1));
		}
		EVE_Cmd_wr32(s_pHalContext, VERTEX2F(xoff, yoff));
		//increment the character after every ittiration
		yoff += TotVtSz;
	}
	return 0;
}

int32_t LiftAppComputeBitmapRowRotate(S_LiftAppFont_t *pLAFont, int32_t FloorNum, uint8_t TotalNumChar, int32_t ResizeVal, int16_t xOffset, int16_t yOffset) {
	/* compute the total number of digits in the input */
	uint8_t TotalChar = 1;
	int32_t TotHzSz, TotVtSz, FlNum, i, xoff, yoff;
	char8_t FontValArray[8];

	TotalChar = 1;
	FlNum = FloorNum;
	TotHzSz = pLAFont->MaxWidth;
	FontValArray[0] = '\0';//requirement from dec2ascii api

	Gpu_Hal_Dec2Ascii(FontValArray, FloorNum);
	TotalChar = strlen(FontValArray);
	if (0 != TotalNumChar) {
		TotalChar = TotalNumChar;
	}
	TotHzSz = (pLAFont->MaxWidth * 16 * ResizeVal) / LIFTAPPCHARRESIZEPRECISION;
	TotVtSz = (pLAFont->MaxHeight * 16 * ResizeVal) / LIFTAPPCHARRESIZEPRECISION;

	//change the x and y offset to center of the characters
	xoff = xOffset * 16 - TotVtSz / 2;
	yoff = yOffset * 16 - (TotHzSz*TotalChar / 2) + (TotHzSz*(TotalChar - 1));
	/* since resize value is same for both the sides the resize is same for all characters */
	for (i = 0; i < TotalChar; i++) {
		/* Calculation of cell number from  */
		if ('-' == FontValArray[i]) {
			EVE_Cmd_wr32(s_pHalContext, CELL(0));
		}
		else {
			EVE_Cmd_wr32(s_pHalContext, CELL(FontValArray[i] - '0' + 1));
		}
		EVE_Cmd_wr32(s_pHalContext, VERTEX2F(xoff, yoff));
		//increment the character after every ittiration
		yoff -= TotHzSz;
	}
	return 0;
}

/**
 * @brief API for single bitmap computation
 * 
 * - follow the above api for more details
 */
int32_t LiftAppComputeBitmap_Single(S_LiftAppFont_t *pLAFont, int32_t BitmapIdx, int32_t ResizeVal, int16_t xOffset, int16_t yOffset) {
	/* compute the total number of digits in the input */
	int32_t TotHzSz, TotVtSz, FlNum, i, xoff, yoff;

	TotHzSz = (pLAFont->MaxWidth * 16 * ResizeVal) / LIFTAPPCHARRESIZEPRECISION;
	TotVtSz = (pLAFont->MaxHeight * 16 * ResizeVal) / LIFTAPPCHARRESIZEPRECISION;

	//change the x and y offset to center of the characters
	xoff = xOffset * 16 - TotHzSz / 2;
	yoff = yOffset * 16 - TotVtSz / 2;

	EVE_Cmd_wr32(s_pHalContext, CELL(BitmapIdx));
	EVE_Cmd_wr32(s_pHalContext, VERTEX2F(xoff, yoff));

	return 0;
}
#ifdef FT93X_PLATFORM
static uint8_t ReadBuff[16 * 1024];
#endif
/**
 * @brief API to play the music files
 * 
 * Option = 0: Load and play audio \n
 * Option = 1: Load audio but do not play \n
 * Option = 2: Play audio only, do not load
 */
uint32_t play_music(char8_t *pFileName, uint32_t dstaddr, uint8_t Option, uint32_t Buffersz) {
#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
#ifdef FT93X_PLATFORM
	uint32_t filesz = 0, chunksize = 8 * 1024, totalbufflen = 8 * 1024, currreadlen = 0;
#else
	uint32_t filesz = 0, chunksize = 16 * 1024, totalbufflen = 32 * 1024, currreadlen = 0;
#endif
	uint8_t *pBuff = NULL;
	uint32_t wrptr = dstaddr, return_val = 0;
	uint32_t rdptr, freebuffspace;
	SDHOST_STATUS    SDHostStatus;
	FATFS            FatFs;				// FatFs work area needed for each volume
	FIL              FilSrc;			// File object needed for each open file
	FIL              FilDes;			// File object needed for each open file
	FRESULT          fResult;			// Return value of FatFs APIs
	unsigned int     numBytesWritten, numBytesRead;
	unsigned char    buffer[32];
	unsigned long    crcSrc, crcDes;
	SDHostStatus = sdhost_card_detect();

	if (sdhost_card_detect() == SDHOST_CARD_INSERTED) {
		printf("\nCard inserted!\n");
	}

	if (f_open(&FilSrc, "SerenadeChopin.raw", FA_READ) != FR_OK) {
		;
	}
#else
	FILE *pFile = NULL;
	uint32_t filesz = 0, chunksize = 16 * 1024, totalbufflen = 64 * 1024, currreadlen = 0;
	uint8_t *pBuff = NULL;
	uint32_t wrptr = dstaddr, return_val = 0;
	uint32_t rdptr, freebuffspace;
#endif
	if (2 == Option) {
		EVE_Hal_wr32(s_pHalContext, REG_PLAYBACK_START, dstaddr);//Audio playback start address 
		EVE_Hal_wr32(s_pHalContext, REG_PLAYBACK_LENGTH, Buffersz);
		EVE_Hal_wr16(s_pHalContext, REG_PLAYBACK_FREQ, 11025);//Frequency
		EVE_Hal_wr8(s_pHalContext, REG_PLAYBACK_FORMAT, ULAW_SAMPLES);//Current sampling frequency
		EVE_Hal_wr8(s_pHalContext, REG_PLAYBACK_LOOP, 0);
		EVE_Hal_wr8(s_pHalContext, REG_VOL_PB, 255);
		EVE_Hal_wr8(s_pHalContext, REG_PLAYBACK_PLAY, 1);
		return 0;
	}
#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	if (0 == music_playing) {
		if (f_open(&FilSrc, pFileName, FA_OPEN_EXISTING | FA_READ) != FR_OK) {
			printf("fail to open: %s\n", pFileName);
		}
	}
	filesz = f_size(&FilSrc);

	f_lseek(&FilSrc, 42);
	fileszsave = filesz;
	printf("\nfilesz %d %s\n", filesz, pFileName);
#ifdef FT93X_PLATFORM
	pBuff = ReadBuff;
#else
	pBuff = (uint8_t *)malloc(totalbufflen);
#endif

	if (pBuff == NULL) {
		printf("NULL pointer\n"); return 0;
	}
	while (filesz > 0) {
		currreadlen = filesz;

		if (currreadlen > chunksize) {
			currreadlen = chunksize;
		}
		f_read(&FilSrc, pBuff, currreadlen, &numBytesRead);
		EVE_Hal_wrMem(s_pHalContext, wrptr, (uint8_t *)pBuff, currreadlen);
		wrptr += currreadlen;
		if (wrptr > (dstaddr + totalbufflen)) {
			wrptr = dstaddr;
		}

		filesz -= currreadlen;
	}

	printf("Success sent\n");

	if ((0 == music_playing) && (0 == Option)) {
		EVE_Hal_wr32(s_pHalContext, REG_PLAYBACK_START, dstaddr);//Audio playback start address
		EVE_Hal_wr32(s_pHalContext, REG_PLAYBACK_LENGTH, fileszsave);
		EVE_Hal_wr16(s_pHalContext, REG_PLAYBACK_FREQ, 11025);//Frequency
		EVE_Hal_wr8(s_pHalContext, REG_PLAYBACK_FORMAT, ULAW_SAMPLES);//Current sampling frequency
		EVE_Hal_wr8(s_pHalContext, REG_PLAYBACK_LOOP, 0);
		EVE_Hal_wr8(s_pHalContext, REG_VOL_PB, 255);
		EVE_Hal_wr8(s_pHalContext, REG_PLAYBACK_PLAY, 1);
		music_playing = 1;
	}

	f_close(&FilSrc);
#ifdef FT93X_PLATFORM
	memset(ReadBuff, 0, sizeof(ReadBuff));
#else
	free(pBuff);
#endif
	if (filesz == 0) {
		dstaddr = dstaddr + fileszsave;
		music_playing = 0;
		return dstaddr;
	}

	else if (0 == Option) {
		rdptr = EVE_Hal_rd32(s_pHalContext, REG_PLAYBACK_READPTR) - dstaddr;
		if ((fileszsave <= rdptr) || (0 == rdptr)) {
			music_playing = 0;
		}
	}
#else
	if (0 == music_playing) {
		pFile = fopen(pFileName, "rb+");
		if (!pFile) {
			return;
		}
		fseek(pFile, 0, SEEK_END);
		filesz = ftell(pFile);

		fseek(pFile, 42, SEEK_SET);
		filesz = 0;
		fread(&filesz, 1, 4, pFile);

		fileszsave = filesz;

		pBuff = (uint8_t *)malloc(totalbufflen);

		while (filesz > 0) {
			currreadlen = filesz;

			if (currreadlen > chunksize) {
				currreadlen = chunksize;
			}
			fread(pBuff, 1, currreadlen, pFile);

			EVE_Hal_wrProgMem(s_pHalContext, wrptr, (uint8_t *)pBuff, currreadlen);
			wrptr += currreadlen;
			if (wrptr > (dstaddr + totalbufflen)) {
				wrptr = dstaddr;
			}

			filesz -= currreadlen;

			if ((0 == music_playing) && (0 == Option)) {
				EVE_Hal_wr32(s_pHalContext, REG_PLAYBACK_START, dstaddr);//Audio playback start address 
				EVE_Hal_wr32(s_pHalContext, REG_PLAYBACK_LENGTH, fileszsave);
				EVE_Hal_wr16(s_pHalContext, REG_PLAYBACK_FREQ, 11025);//Frequency
				EVE_Hal_wr8(s_pHalContext, REG_PLAYBACK_FORMAT, ULAW_SAMPLES);//Current sampling frequency
				EVE_Hal_wr8(s_pHalContext, REG_PLAYBACK_LOOP, 0);
				EVE_Hal_wr8(s_pHalContext, REG_VOL_PB, 255);
				EVE_Hal_wr8(s_pHalContext, REG_PLAYBACK_PLAY, 1);
				music_playing = 1;
			}

			{
				//Check the frees0ace if the file has more
				rdptr = EVE_Hal_rd32(s_pHalContext, REG_PLAYBACK_READPTR);
				while (totalbufflen < fileszsave) {
					EVE_CoCmd_memSet(s_pHalContext, wrptr, 0, chunksize);
				}

			}
		}

		//if read pointer is already passed over write pointer
		if (EVE_Hal_rd32(s_pHalContext, REG_PLAYBACK_READPTR) > wrptr) {
			//wait till the read pointer will be wrapped over 
			while (EVE_Hal_rd32(s_pHalContext, REG_PLAYBACK_READPTR) > wrptr);
		}
		fclose(pFile);
		free(pBuff);
		if (filesz == 0) {
			dstaddr = dstaddr + fileszsave;
			music_playing = 0;
			return dstaddr;
		}
	}
	else if (0 == Option) {
		rdptr = EVE_Hal_rd32(s_pHalContext, REG_PLAYBACK_READPTR) - dstaddr;
		if ((fileszsave <= rdptr) || (0 == rdptr)) {
			music_playing = 0;
		}

	}
#endif
	/* return the current write pointer in any case */
	return wrptr;
}
#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
int32_t LiftApp_FTransition(S_LiftAppCtxt_t *pLACtxt, uint32_t dstaddr) {
	char8_t StringArray[100], StringArray_mid[100], audio_array[100];
	int32_t dst_addr_st_file;
	StringArray[0] = '\0';
	StringArray_mid[0] = '\0';
	/* check for the current floor number logic */
	if (pLACtxt->CurrFloorNum == pLACtxt->NextFloorNum) {
		/* first time only entry */
		if (LIFTAPP_DIR_NONE != pLACtxt->ArrowDir) {
			pLACtxt->CurrFloorNumStagnantRate = pLACtxt->SLATransPrms.FloorNumStagnantRate;
			pLACtxt->CurrFloorNumResizeRate = pLACtxt->SLATransPrms.ResizeRate;
		}
		/* Make the direction to 0 */
		pLACtxt->ArrowDir = LIFTAPP_DIR_NONE;//arrow is disabled in none direction
		{
			if ((0 == pLACtxt->AudioPlaying) && (1 == pLACtxt->Orientation)) {
				/* load the ring tone */
				dst_addr_st_file = play_music(TEST_DIR "\\bl.wav", dstaddr, 1, 0);

				/* load the floor number audio */

				Gpu_Hal_Dec2Ascii(StringArray, (int32_t)pLACtxt->CurrFloorNum);
				strcat(StringArray_mid, TEST_DIR "\\");
				strcat(StringArray_mid, StringArray);
				strcat(StringArray_mid, ".wav");
				dst_addr_st_file = play_music(StringArray_mid, dst_addr_st_file, 1, 0);
				play_music(StringArray_mid, dstaddr, 2, dst_addr_st_file - dstaddr);
				pLACtxt->AudioPlaying = 1;

			}

			else if ((0 == pLACtxt->AudioPlaying) && (0 == pLACtxt->Orientation)) {
				/* load the ring tone */
				dst_addr_st_file = play_music(TEST_DIR "\\bf.wav", dstaddr, 1, 0);

				/* load the floor number audio */

				Gpu_Hal_Dec2Ascii(StringArray, (int32_t)pLACtxt->CurrFloorNum);
				strcat(StringArray_mid, TEST_DIR "\\");
				strcat(StringArray_mid, StringArray);
				strcat(StringArray_mid, ".wav");
				dst_addr_st_file = play_music(StringArray_mid, dst_addr_st_file, 1, 0);
				play_music(StringArray_mid, dstaddr, 2, dst_addr_st_file - dstaddr);
				pLACtxt->AudioPlaying = 1;

			}

		}

		/* resizing of floor number */
		if (pLACtxt->CurrFloorNumResizeRate > 0) {
			pLACtxt->CurrFloorNumResizeRate--;
			return 0;
		}
		pLACtxt->CurrFloorNumResizeRate = 0;

		/* rate implmenetation */
		if (pLACtxt->CurrFloorNumStagnantRate > 0) {
			pLACtxt->CurrFloorNumStagnantRate--;//rate based logic
			return 0;//do not perform any thing
		}
		pLACtxt->CurrFloorNumStagnantRate = 0;
		pLACtxt->AudioPlaying = 0;
		/* delay the below code till rate is completed - modify the rate if application over rights */
		//limitation - make sure the max is +ve
		while ((pLACtxt->CurrFloorNum == pLACtxt->NextFloorNum) || (0 == pLACtxt->NextFloorNum))//to make sure the same floor number is not assigned
		{
			pLACtxt->NextFloorNum = pLACtxt->SLATransPrms.MinFloorNum + random(pLACtxt->SLATransPrms.MaxFloorNum - pLACtxt->SLATransPrms.MinFloorNum);
		}

		pLACtxt->ArrowDir = LIFTAPP_DIR_DOWN;
		/* generate a new random number and change the direction as well */
		if (pLACtxt->NextFloorNum > pLACtxt->CurrFloorNum) {
			pLACtxt->ArrowDir = LIFTAPP_DIR_UP;
			play_music(TEST_DIR "\\gu.wav", dstaddr, 0, 0);
		}
		else {
			play_music(TEST_DIR "\\gd.wav", dstaddr, 0, 0);
		}

		/* set the starting of the arrow resize */
		pLACtxt->CurrArrowResizeRate = pLACtxt->SLATransPrms.ResizeRate;
		//set the curr floor number change 
		pLACtxt->CurrFloorNumChangeRate = pLACtxt->SLATransPrms.FloorNumChangeRate;
		return 0;
	}

	/* moving up or moving down logic */
	/* rate based on count */
	pLACtxt->CurrArrowResizeRate--;
	if (pLACtxt->CurrArrowResizeRate <= 0) {
		pLACtxt->CurrArrowResizeRate = pLACtxt->SLATransPrms.ResizeRate;
	}
	//changing floor numbers
	pLACtxt->CurrFloorNumChangeRate--;
	if (pLACtxt->CurrFloorNumChangeRate <= 0) {
		pLACtxt->CurrFloorNumChangeRate = pLACtxt->SLATransPrms.FloorNumChangeRate;
		//change the floor number wrt direction
		if (LIFTAPP_DIR_DOWN == pLACtxt->ArrowDir) {
			pLACtxt->CurrFloorNum -= 1;
			if (0 == pLACtxt->CurrFloorNum) {
				pLACtxt->CurrFloorNum -= 1;
			}
		}
		else {
			pLACtxt->CurrFloorNum += 1;
			if (0 == pLACtxt->CurrFloorNum) {
				pLACtxt->CurrFloorNum += 1;
			}
		}
	}
	return 0;
}

#else
/** 
 * @brief API for floor number logic
 */
int32_t LiftApp_FTransition(S_LiftAppCtxt_t *pLACtxt, uint32_t dstaddr) {
	char8_t StringArray[100], StringArray_mid[100], audio_array[100], tmp;
	int32_t dst_addr_st_file;
	StringArray[0] = '\0';
	StringArray_mid[0] = '\0';
	/* check for the current floor number logic */
	if (pLACtxt->CurrFloorNum == pLACtxt->NextFloorNum) {
		/* first time only entry */
		if (LIFTAPP_DIR_NONE != pLACtxt->ArrowDir) {
			pLACtxt->CurrFloorNumStagnantRate = pLACtxt->SLATransPrms.FloorNumStagnantRate;
			pLACtxt->CurrFloorNumResizeRate = pLACtxt->SLATransPrms.ResizeRate;
		}
		/* Make the direction to 0 */
		pLACtxt->ArrowDir = LIFTAPP_DIR_NONE;//arrow is disabled in none direction
		{
			if ((0 == pLACtxt->AudioPlaying) && (1 == pLACtxt->Orientation)) {
				/* load the ring tone */
				dst_addr_st_file = play_music(TEST_DIR "\\bl.wav", dstaddr, 1, 0);/* load the floor number audio */

																				  /* load the floor number audio */
				strcat(StringArray_mid, TEST_DIR "\\");
				if (pLACtxt->CurrFloorNum) {
					Gpu_Hal_Dec2Ascii(StringArray, (int32_t)pLACtxt->CurrFloorNum);
					strcat(StringArray_mid, StringArray);
					strcat(StringArray_mid, ".wav");
					dst_addr_st_file = play_music(StringArray_mid, dst_addr_st_file, 1, 0);
					play_music(StringArray_mid, dstaddr, 2, dst_addr_st_file - dstaddr);
				}
				pLACtxt->AudioPlaying = 1;
			}
			else if ((0 == pLACtxt->AudioPlaying) && (0 == pLACtxt->Orientation)) {
				/* load the ring tone */
				dst_addr_st_file = play_music(TEST_DIR "\\bf.wav", dstaddr, 1, 0);

				/* load the floor number audio */
				strcat(StringArray_mid, TEST_DIR "\\");
				Gpu_Hal_Dec2Ascii(StringArray, (int32_t)pLACtxt->CurrFloorNum);
				strcat(StringArray_mid, StringArray);
				strcat(StringArray_mid, ".wav");
				dst_addr_st_file = play_music(StringArray_mid, dst_addr_st_file, 1, 0);
				play_music(StringArray_mid, dstaddr, 2, dst_addr_st_file - dstaddr);
				pLACtxt->AudioPlaying = 1;
			}
		}

		/* resizing of floor number */
		if (pLACtxt->CurrFloorNumResizeRate > 0) {
			pLACtxt->CurrFloorNumResizeRate--;
			return 0;
		}
		pLACtxt->CurrFloorNumResizeRate = 0;

		/* rate implmenetation */
		if (pLACtxt->CurrFloorNumStagnantRate > 0) {
			pLACtxt->CurrFloorNumStagnantRate--;//rate based logic
			return 0;//do not perform any thing
		}
		pLACtxt->CurrFloorNumStagnantRate = 0;
		pLACtxt->AudioPlaying = 0;
		/* delay the below code till rate is completed - modify the rate if application over rights */
		//limitation - make sure the max is +ve
		while ((pLACtxt->CurrFloorNum == pLACtxt->NextFloorNum) || (0 == pLACtxt->NextFloorNum))//to make sure the same floor number is not assigned
		{
			pLACtxt->NextFloorNum = pLACtxt->SLATransPrms.MinFloorNum + random(pLACtxt->SLATransPrms.MaxFloorNum - pLACtxt->SLATransPrms.MinFloorNum);
		}

		/* generate a new random number and change the direction as well */
		if (pLACtxt->NextFloorNum > pLACtxt->CurrFloorNum) {
			pLACtxt->ArrowDir = LIFTAPP_DIR_UP;
			play_music(TEST_DIR "\\gu.wav", dstaddr, 0, 0);
		}
		else {
			pLACtxt->ArrowDir = LIFTAPP_DIR_DOWN;
			play_music(TEST_DIR "\\gd.wav", dstaddr, 0, 0);
		}

		/* set the starting of the arrow resize */
		pLACtxt->CurrArrowResizeRate = pLACtxt->SLATransPrms.ResizeRate;
		//set the curr floor number change
		pLACtxt->CurrFloorNumChangeRate = pLACtxt->SLATransPrms.FloorNumChangeRate;
		return 0;
	}

	/* moving up or moving down logic */
	/* rate based on count */

	pLACtxt->CurrArrowResizeRate--;
	if (pLACtxt->CurrArrowResizeRate <= 0) {
		pLACtxt->CurrArrowResizeRate = pLACtxt->SLATransPrms.ResizeRate;
	}
	//changing floor numbers
	pLACtxt->CurrFloorNumChangeRate--;
	if (pLACtxt->CurrFloorNumChangeRate <= 0) {
		pLACtxt->CurrFloorNumChangeRate = pLACtxt->SLATransPrms.FloorNumChangeRate;
		//change the floor number wrt direction
		if (LIFTAPP_DIR_DOWN == pLACtxt->ArrowDir) {
			pLACtxt->CurrFloorNum -= 1;
			if (0 == pLACtxt->CurrFloorNum) {
				pLACtxt->CurrFloorNum -= 1;
			}
		}
		else {
			pLACtxt->CurrFloorNum += 1;
			if (0 == pLACtxt->CurrFloorNum) {
				pLACtxt->CurrFloorNum += 1;
			}
		}
	}
	return 0;
}
#endif
/** 
 * @brief API to get the rate of the running text
 */
float linear(float p1, float p2, uint16_t t, uint16_t rate) {
	float st = (float)t / rate;
	return p1 + (st*(p2 - p1));
}

/** 
 * @brief API to display the fonts in both portrait and landscape orientations
 */
void font_display(int16_t BMoffsetx, int16_t BMoffsety, uint32_t stringlenghth, char8_t *string_display, uint8_t opt_landscape) {
	uint16_t k;
	if (0 == opt_landscape) {
		for (k = 0; k < stringlenghth; k++) {
#ifdef DISPLAY_RESOLUTION_WVGA
			EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(8));
			EVE_Cmd_wr32(s_pHalContext, CELL(string_display[k]));
			EVE_Cmd_wr32(s_pHalContext, VERTEX2F(BMoffsetx * 16, BMoffsety * 16));
#else
			EVE_Cmd_wr32(s_pHalContext, VERTEX2II(BMoffsetx, BMoffsety, 8, string_display[k]));
#endif
			BMoffsety -= g_Gpu_Fonts[8].FontWidth[string_display[k]];
		}
	}
	else if (1 == opt_landscape) {
		for (k = 0; k < stringlenghth; k++) {
#ifdef DISPLAY_RESOLUTION_WVGA
			EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(28));
			EVE_Cmd_wr32(s_pHalContext, CELL(string_display[k]));
			EVE_Cmd_wr32(s_pHalContext, VERTEX2F(BMoffsetx * 16, BMoffsety * 16));
#else
			EVE_Cmd_wr32(s_pHalContext, VERTEX2II(BMoffsetx, BMoffsety, 28, string_display[k]));

#endif
			BMoffsetx += g_Gpu_Fonts[8].FontWidth[string_display[k]];
		}

	}
}

/**
 * @brief Lift demo application demonstrates background animation and foreground digits and arrow direction in landscape orientation
 */
void LiftApp_Landscape() {
	/* Download the raw data of custom fonts into memory */
	int16_t BMoffsetx, BMoffsety, BHt = 156, BWd = 80, BSt = 80, Bfmt = L8, BArrowHt = 85, BArrowWd = 80, BArrowSt = 80, BArrowfmt = L8;
	int16_t NumBallsRange = 6, NumBallsEach = 10, RandomVal = 16, xoffset, yoffset;
	int32_t Baddr0, Baddr1, Baddr2, i, SzInc = 16, SzFlag = 0;
	uint8_t fontr = 255, fontg = 255, fontb = 255, minute_temp, day_temp;
	S_LiftAppRate_t *pLARate;
	S_LiftAppTrasParams_t *pLATParams;
	S_LiftAppBallsLinear_t S_LiftBallsArray[8 * 10], *pLiftBalls = NULL;//as of now 80 balls are been plotted
	App_GraphicsMatrix_t S_GPUMatrix;
	App_PostProcess_Transform_t S_GPUTrasMatrix;
	float temptransx, temptransy, running_rate;
	S_LiftAppCtxt_t S_LACtxt;

#if !defined(FT9XX_PLATFORM) && !defined(RP2040_PLATFORM)

	SYSTEMTIME st, lt;
#else
	static unsigned int curr_rtc_clock;
	static uint32_t  counter, time_curr, tt, count_t;
	_localtime st, lt;
#endif

	uint16_t hour, hour_st, hour_nd, min, min_st, min_nd, sec, year, month, day, year_st_nd_dig, year_st_dig, year_nd_dig, year_rd_frth_dig, year_rd_dig, year_frth_dig;
	uint16_t day_st, day_nd;
	char8_t *day_of_week = " Sun, ", nd_line[100];
	char8_t text_run_disp[] = "The running text is displayed here.";
	char8_t *hour_st_str, *hour_nd_str, *min_st_str, *min_nd_str, *day_st_str, *day_nd_str, *year_st_str, *year_nd_str, *year_rd_str, *year_frth_str;
	char8_t* month_of_year;
	uint32_t stringlen, FontTableAddress, k, j, l, stringlen_week, stringlen_day, stringlen_text_run_disp, stringlen_st;
	int32_t FontWid = 0;

	uint8_t *pbuff;
	int32_t FileLen = 0;
	Gpu_Fonts_t Display_fontstruct;
	float t = 0;
#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	float ttt;
#endif
	uint16_t m;

	nd_line[0] = '0';
#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	curr_rtc_clock++;
	time_curr = curr_rtc_clock % 1024;
	t = curr_rtc_clock / 32768 * 1000 % 1000;
	if (time_curr < tt) {
		count_t++;
	}
#endif
	/* load the bitmap raw data */

	/* Initial setup code to setup all the required bitmap handles globally */
	App_Set_DlBuffer_Index(0);

#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	pLARate->IttrCount = &S_LACtxt.SLARate.IttrCount;
#else
	pLARate = &S_LACtxt.SLARate;
#endif
	pLATParams = &S_LACtxt.SLATransPrms;

	//initialize all the rate parameters
	pLARate->CurrTime = 0;
	pLARate->IttrCount = 0;

	/* Initialize all the transition parameters - all the below are in terms of basic units of rate
	either they can be based on itterations or based on time giffies */
	pLATParams->FloorNumChangeRate = 64;
	pLATParams->MaxFloorNum = 7;
	pLATParams->MinFloorNum = -2;
	pLATParams->ResizeRate = 32;
	pLATParams->ResizeDimMax = 2 * 256;
	pLATParams->ResizeDimMin = 1 * 256;
	pLATParams->FloorNumStagnantRate = 180;

	/* Initialization of lift context parameters */
	S_LACtxt.ArrowDir = LIFTAPP_DIR_DOWN;//going down direction
	S_LACtxt.CurrFloorNum = 5;//current floor number to start with
	S_LACtxt.NextFloorNum = -2;//destination floor number as of now
	S_LACtxt.CurrArrowResizeRate = pLATParams->ResizeRate;
	S_LACtxt.CurrFloorNumResizeRate = pLATParams->ResizeRate;
	S_LACtxt.CurrFloorNumStagnantRate = 0;
	S_LACtxt.CurrFloorNumChangeRate = S_LACtxt.SLATransPrms.FloorNumChangeRate;
	S_LACtxt.AudioPlaying = 0;
	S_LACtxt.Orientation = 1;


	EVE_CoCmd_dlStart(s_pHalContext);

	EVE_Cmd_wr32(s_pHalContext, CLEAR_COLOR_RGB(255, 255, 255));
	EVE_Cmd_wr32(s_pHalContext, CLEAR(1, 1, 1)); // clear screen

	EVE_Cmd_wr32(s_pHalContext, BEGIN(BITMAPS));
	Baddr0 = RAM_G;

#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\font.raw", RAM_G, LOAD);
#else
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\font.raw", RAM_G, LOAD);
#endif
	EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(0));//handle 0 is used for all the characters
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(Baddr0));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_LAYOUT(Bfmt, BSt, BHt));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(BILINEAR, BORDER, BORDER, BWd * 2, BHt * 2));

	Baddr1 = ((Baddr0 + BSt*BHt * 11 + 15)&~15);

#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\arr.raw", Baddr1, LOAD);
#else
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\arr.raw", Baddr1, LOAD);
#endif
	EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(1));//bitmap handle 1 is used for arrow
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(Baddr1));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_LAYOUT(BArrowfmt, BArrowSt, BArrowHt));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(BILINEAR, BORDER, BORDER, BArrowWd * 2, BArrowHt * 2));//make sure the bitmap is displayed when rotation happens

	Baddr2 = Baddr1 + 80 * 85;

#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs6.raw", Baddr2, LOAD);
#else
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs6.raw", Baddr2, LOAD);
#endif
	EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(2));//bitmap handle 2 is used for background balls
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(Baddr2));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_LAYOUT(L8, 60, 60));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(NEAREST, BORDER, BORDER, 60, 55));
	Baddr2 += 60 * 55;

#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs5.raw", Baddr2, LOAD);
#else
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs5.raw", Baddr2, LOAD);
#endif
	EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(3));//bitmap handle 2 is used for background balls
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(Baddr2));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_LAYOUT(L8, 50, 46));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(NEAREST, BORDER, BORDER, 50, 46));
	Baddr2 += 50 * 46;

#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs4.raw", Baddr2, LOAD);
#else
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs4.raw", Baddr2, LOAD);
#endif

	EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(4));//bitmap handle 2 is used for background balls
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(Baddr2));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_LAYOUT(L8, 40, 37));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(NEAREST, BORDER, BORDER, 40, 37));
	Baddr2 += 40 * 37;

#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs3.raw", Baddr2, LOAD);
#else
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs3.raw", Baddr2, LOAD);
#endif
	EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(5));//bitmap handle 2 is used for background balls
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(Baddr2));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_LAYOUT(L8, 30, 27));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(NEAREST, BORDER, BORDER, 30, 27));
	Baddr2 += 30 * 27;

#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs2.raw", Baddr2, LOAD);
#else
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs2.raw", Baddr2, LOAD);
#endif
	EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(6));//bitmap handle 2 is used for background balls
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(Baddr2));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_LAYOUT(L8, 20, 18));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(NEAREST, BORDER, BORDER, 20, 18));
	Baddr2 += 20 * 18;
#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs1.raw", Baddr2, LOAD);
#else
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs1.raw", Baddr2, LOAD);
#endif

	EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(7));//bitmap handle 2 is used for background balls
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(Baddr2));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_LAYOUT(L8, 10, 10));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(NEAREST, BORDER, BORDER, 10, 10));
	EVE_Cmd_wr32(s_pHalContext, VERTEX2II(0, 0, 7, 0));
	Baddr2 += 10 * 10;

#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\logo.raw", Baddr2, LOAD);
#else
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\logo.raw", Baddr2, LOAD);
#endif
	EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(11));//handle 11 is used for logo
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(Baddr2));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_LAYOUT(ARGB4, 99 * 2, 30));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(BILINEAR, BORDER, BORDER, 99, 30));//make sure whole bitmap is displayed after rotation - as height is greater than width
	Baddr2 += 99 * 2 * 30;

	// Read the font address from 0xFFFFC location 

	FontTableAddress = EVE_Hal_rd32(s_pHalContext, 0xFFFFC);

	App_Set_CmdBuffer_Index(0);

	Baddr2 += 10 * 10;
	Baddr2 = ((Baddr2 + 7)&~7);//audio engine's requirement

	EVE_Cmd_wr32(s_pHalContext, DISPLAY());
	EVE_CoCmd_swap(s_pHalContext);
	/* Download the DL into DL RAM */
	App_Flush_DL_Buffer(s_pHalContext);
	/* Download the commands into fifo */
	EVE_Cmd_waitFlush(s_pHalContext);
	EVE_Cmd_waitFlush(s_pHalContext);
	EVE_sleep(30);

	/* compute the random values at the starting */
	pLiftBalls = S_LiftBallsArray;
	for (i = 0; i < (NumBallsRange*NumBallsEach); i++) {
		pLiftBalls->xOffset = random(s_pHalContext->Width * 16);
		pLiftBalls->yOffset = random(s_pHalContext->Height * 16);
		pLiftBalls->dx = random(RandomVal * 8) - RandomVal * 4;
		pLiftBalls->dy = -1 * random(RandomVal * 8);
		pLiftBalls++;
	}
#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	st.wHour = 15;
	st.wMinute = 59;
	st.wDay = 5;
	lt.wDayOfWeek = 3;
	st.wYear = 2017;
	st.wMilliseconds = 0;
	st.wSecond = 0;
	st.wMonth = 11;
#endif
	while (1) {
		/* Logic of user touch - change background or skin wrt use touch */
		/* Logic of transition - change of floor numbers and direction */
		LiftApp_FTransition(&S_LACtxt, Baddr2);

		EVE_CoCmd_dlStart(s_pHalContext);
		EVE_Cmd_wr32(s_pHalContext, CLEAR_COLOR_RGB(255, 255, 255));
		EVE_Cmd_wr32(s_pHalContext, CLEAR(1, 1, 1)); // clear screen
		EVE_Cmd_wr32(s_pHalContext, COLOR_RGB(255, 255, 255));
		/* Background gradient */
		EVE_CoCmd_gradient(s_pHalContext, 0, 0, 0x66B4E8, 0, s_pHalContext->Height, 0x132B3B);

		/* Draw background bitmaps */
		EVE_Cmd_wr32(s_pHalContext, COLOR_RGB(0, 0, 0));
		pLiftBalls = S_LiftBallsArray;
		EVE_Cmd_wr32(s_pHalContext, BEGIN(BITMAPS));

		EVE_Cmd_wr32(s_pHalContext, COLOR_A(64));
		EVE_Cmd_wr32(s_pHalContext, COLOR_RGB(255, 255, 255));
		for (i = 0; i < (NumBallsRange*NumBallsEach); i++) {
			/* handle inst insertion - check for the index */
			if (0 == (i%NumBallsEach)) {
				EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(2 + (i / NumBallsEach)));
			}
			/* recalculate the background balls offset and respective rate when ball moves out of the diaply area */
			if ((pLiftBalls->xOffset >((s_pHalContext->Width + 60) * 16)) ||
				(pLiftBalls->yOffset > ((s_pHalContext->Height + 60) * 16)) ||
				(pLiftBalls->xOffset < (-60 * 16)) ||
				(pLiftBalls->yOffset < (-60 * 16))) {
				/* always offset starts from below the screen and moves upwards */
				pLiftBalls->xOffset = random(s_pHalContext->Width * 16);
				pLiftBalls->yOffset = s_pHalContext->Height * 16 + random(60 * 16);

				pLiftBalls->dx = random(RandomVal * 8) - RandomVal * 4;
				pLiftBalls->dy = -1 * random(RandomVal * 8);
			}
			EVE_Cmd_wr32(s_pHalContext, VERTEX2F(pLiftBalls->xOffset, pLiftBalls->yOffset));
			pLiftBalls->xOffset += pLiftBalls->dx;
			pLiftBalls->yOffset += pLiftBalls->dy;
			pLiftBalls++;
		}
		EVE_Cmd_wr32(s_pHalContext, END());
		EVE_Cmd_wr32(s_pHalContext, ALPHA_FUNC(ALWAYS, 0));
		EVE_Cmd_wr32(s_pHalContext, COLOR_A(255));

		if (LIFTAPP_DIR_NONE != S_LACtxt.ArrowDir)//do not display the arrow in case of no direction, meaning stagnant
		{
			//calculation of size value based on the rate
			//the bitmaps are scaled from original resolution till 2 times the resolution on both x and y axis
			SzInc = 16 + (S_LACtxt.SLATransPrms.ResizeRate / 2 - abs(S_LACtxt.CurrArrowResizeRate%S_LACtxt.SLATransPrms.ResizeRate - S_LACtxt.SLATransPrms.ResizeRate / 2));
			EVE_Cmd_wr32(s_pHalContext, COLOR_RGB(fontr, fontg, fontb));
			/* Draw the arrow first */
			EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(1));
			EVE_Cmd_wr32(s_pHalContext, BEGIN(BITMAPS)); // start drawing bitmaps
			BMoffsetx = (BArrowWd - (BArrowWd*SzInc / 32));
			BMoffsety = ((s_pHalContext->Height / 2) - (BArrowHt*SzInc / 32));

			/* perform inplace flip and scale of bitmap in case of direction is up */
			if (LIFTAPP_DIR_UP == S_LACtxt.ArrowDir) {
				EVE_Cmd_wr32(s_pHalContext, SAVE_CONTEXT());
				App_TrsMtrxLoadIdentity(&S_GPUMatrix);
				App_TrsMtrxTranslate(&S_GPUMatrix, 80 / 2.0, 85 / 2.0, &temptransx, &temptransy);
				App_TrsMtrxScale(&S_GPUMatrix, (SzInc / 16.0), (SzInc / 16.0));
				App_TrsMtrxFlip(&S_GPUMatrix, APP_GRAPHICS_FLIP_BOTTOM);
				App_TrsMtrxTranslate(&S_GPUMatrix, (-80 * SzInc) / 32.0, (-85 * SzInc) / 32.0, &temptransx, &temptransy);

				App_UpdateTrsMtrx(&S_GPUMatrix, &S_GPUTrasMatrix);
				EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_A(S_GPUTrasMatrix.Transforma));
				EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_B(S_GPUTrasMatrix.Transformb));
				EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_C(S_GPUTrasMatrix.Transformc));
				EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_D(S_GPUTrasMatrix.Transformd));
				EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_E(S_GPUTrasMatrix.Transforme));
				EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_F(S_GPUTrasMatrix.Transformf));
			}
			else if (LIFTAPP_DIR_DOWN == S_LACtxt.ArrowDir) {
				//perform only scaling as rotation is not required
				EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_A(256 * 16 / SzInc));
				EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_E(256 * 16 / SzInc));
			}
			//adjust the location  of arrow
#ifdef DISPLAY_RESOLUTION_WVGA
			LiftAppComputeBitmap(G_LiftAppFontArrayArrow, -1, 1, SzInc * 16, BArrowWd * 2 + 40, (s_pHalContext->Height * 2 / 4));

#elif defined DISPLAY_RESOLUTION_HVGA_PORTRAIT
			LiftAppComputeBitmap(G_LiftAppFontArrayArrow, -1, 1, SzInc * 16, BArrowWd * 2, (s_pHalContext->Height * 2 / 8));
#else
			LiftAppComputeBitmap(G_LiftAppFontArrayArrow, -1, 1, SzInc * 16, BArrowWd, (s_pHalContext->Height / 2));
#endif
			EVE_CoCmd_loadIdentity(s_pHalContext);
			EVE_CoCmd_setMatrix(s_pHalContext);
			if (LIFTAPP_DIR_UP == S_LACtxt.ArrowDir) {
				EVE_Cmd_wr32(s_pHalContext, RESTORE_CONTEXT());
			}
		}
		/* Draw the font bitmaps */
		/* algorithm for animation - floor numbers will change in dimensions when stagnant at a perticular floor */
		/* arrow will change in case of movement of lift */
		/* display the bitmap with increased size */
		SzInc = 16 + (S_LACtxt.SLATransPrms.ResizeRate / 2 - abs(S_LACtxt.CurrFloorNumResizeRate%S_LACtxt.SLATransPrms.ResizeRate - S_LACtxt.SLATransPrms.ResizeRate / 2));
		BMoffsetx = s_pHalContext->Width - BWd * 2 - (BWd*SzInc / 32);

		BMoffsety = ((s_pHalContext->Height / 2) - (BHt*SzInc / 32));
		/* calculate the resolution change based on the number of characters used as well as */
		EVE_Cmd_wr32(s_pHalContext, COLOR_RGB(fontr, fontg, fontb));
		EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_A(256 * 16 / SzInc));
		EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_E(256 * 16 / SzInc));
		EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(0));
		EVE_Cmd_wr32(s_pHalContext, BEGIN(BITMAPS)); // start drawing bitmaps

        //adjust the number location
#ifdef DISPLAY_RESOLUTION_WVGA
		LiftAppComputeBitmap(G_LiftAppFontArrayNumbers, S_LACtxt.CurrFloorNum, 0, SzInc * 16, s_pHalContext->Width * 3 / 4, (s_pHalContext->Height / 2));

#elif defined DISPLAY_RESOLUTION_HVGA_PORTRAIT
		LiftAppComputeBitmap(G_LiftAppFontArrayNumbers, S_LACtxt.CurrFloorNum, 0, SzInc * 16, s_pHalContext->Width / 2, (s_pHalContext->Height * 3 / 4));
#else
		LiftAppComputeBitmap(G_LiftAppFontArrayNumbers, S_LACtxt.CurrFloorNum, 0, SzInc * 16, s_pHalContext->Width - BWd * 2, (s_pHalContext->Height / 2));
#endif	

#if !defined(FT9XX_PLATFORM) && !defined(RP2040_PLATFORM)
		GetSystemTime(&st);
		GetLocalTime(&lt);
#else

		curr_rtc_clock++;

		time_curr = curr_rtc_clock % 32;
		t = curr_rtc_clock / 32 * 1000 % 1000;
		if (time_curr < tt) {
			count_t++;
		}

		lt.wSecond = curr_rtc_clock / 32 % 60;
		lt.wMinute = (curr_rtc_clock / 32 / 60 + st.wMinute) % 60;

		if (lt.wMinute < minute_temp) {
			st.wHour++;
		}
		minute_temp = lt.wMinute;
		lt.wHour = (curr_rtc_clock / 32 / 3600 + st.wHour) % 12;

		if (lt.wDay < day_temp) {
			st.wDay++;
		}
		lt.wDay = (curr_rtc_clock / 32 / 3600 / 24 + st.wDay) % 30;
		day_temp = lt.wDay;
		lt.wMonth = st.wMonth;
		lt.wYear = 2017;

#endif
		hour = (uint16_t)lt.wHour;
		min = (uint16_t)lt.wMinute;
		year = (uint16_t)lt.wYear;
		month = (uint16_t)lt.wMonth;
		day = (uint16_t)lt.wDay;

		if (lt.wMonth == 1) {
			month_of_year = " January ";
		}
		else if (lt.wMonth == 2) {
			month_of_year = " February ";
		}
		else if (lt.wMonth == 3) {
			month_of_year = " March ";
		}
		else if (lt.wMonth == 4) {
			month_of_year = " April ";
		}
		else if (lt.wMonth == 5) {
			month_of_year = " May ";
		}
		else if (lt.wMonth == 6) {
			month_of_year = " June ";
		}
		else if (lt.wMonth == 7) {
			month_of_year = " July ";
		}
		else if (lt.wMonth == 8) {
			month_of_year = " August ";
		}
		else if (lt.wMonth == 9) {
			month_of_year = " September ";
		}
		else if (lt.wMonth == 10) {
			month_of_year = " October ";
		}
		else if (lt.wMonth == 11) {
			month_of_year = " November ";
		}
		else if (lt.wMonth == 12) {
			month_of_year = " December ";
		}
		if (lt.wDayOfWeek == 0) {
			day_of_week = " Sun, ";
		}
		else if (lt.wDayOfWeek == 1) {
			day_of_week = "Mon, ";
		}
		else if (lt.wDayOfWeek == 2) {
			day_of_week = "Tue, ";
		}
		else if (lt.wDayOfWeek == 3) {
			day_of_week = "Wed, ";
		}
		else if (lt.wDayOfWeek == 4) {
			day_of_week = "Thur, ";
		}
		else if (lt.wDayOfWeek == 5) {
			day_of_week = "Fri, ";
		}
		else if (lt.wDayOfWeek == 6) {
			day_of_week = "Sat, ";
		}

		EVE_Cmd_wr32(s_pHalContext, BEGIN(BITMAPS));
		BMoffsetx = 10;
		BMoffsety = s_pHalContext->Height - 80;

		if (hour > 9) {
			hour_st = (hour / 10) + '0';
			hour_nd = (hour % 10) + '0';
			hour_st_str = &hour_st;
			hour_nd_str = &hour_nd;
			strcat(hour_st_str, hour_nd_str);
		}
		else {
			hour = hour + '0';
			hour_st_str = &hour;
			strcpy(hour_st_str, hour_st_str);
		}

		strcat(hour_st_str, ":");

		min_st = min / 10 + '0';
		min_nd = min % 10 + '0';
		min_st_str = &min_st;
		min_nd_str = &min_nd;
		strcat(min_st_str, min_nd_str);
		strcat(hour_st_str, min_st_str);
		stringlen_st = strlen(hour_st_str);

		font_display(BMoffsetx, BMoffsety, stringlen_st, hour_st_str, 1);

		BMoffsety += 20;

		strcpy(&nd_line, day_of_week);

		day_st = (day / 10) + '0';
		day_nd = (day % 10) + '0';
		day_st_str = &day_st;
		day_nd_str = &day_nd;

		strcat(day_st_str, day_nd_str);

		strcat(&nd_line, day_st_str);

		strcat(&nd_line, month_of_year);

#ifndef DISPLAY_RESOLUTION_QVGA

		year_st_nd_dig = year / 100;
		year_st_dig = (year_st_nd_dig / 10) + '0';
		year_nd_dig = year_st_nd_dig % 10 + '0';
		year_rd_frth_dig = year % 100;
		year_rd_dig = (year_rd_frth_dig / 10) + '0';
		year_frth_dig = (year_rd_frth_dig % 10) + '0';

		year_st_str = &year_st_dig;
		year_nd_str = &year_nd_dig;
		year_rd_str = &year_rd_dig;
		year_frth_str = &year_frth_dig;

		strcat(year_st_str, year_nd_str);
		strcat(&nd_line, year_st_str);
		strcat(year_rd_str, year_frth_str);
		strcat(&nd_line, year_rd_str);
#endif
		stringlen_st = strlen(nd_line);
		font_display(BMoffsetx, BMoffsety, stringlen_st, nd_line, 1);

		EVE_Cmd_wr32(s_pHalContext, BEGIN(BITMAPS));
		EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_A(256));
		EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_E(256));

		stringlen_text_run_disp = strlen(text_run_disp);
		BMoffsety += 20;
#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
		if (t < 200) {
			t++;
			ttt++;
		}
		BMoffsetx = linear(800, 0, ttt, 200);
#else

		if (t < 200)
			t++;
		BMoffsetx = linear(480, 0, t, 200);
#endif

		font_display(BMoffsetx, BMoffsety, stringlen_text_run_disp, text_run_disp, 1);

		EVE_Cmd_wr32(s_pHalContext, BEGIN(BITMAPS));
		EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(11));
		EVE_Cmd_wr32(s_pHalContext, VERTEX2II(10, 10, 11, 0));

		EVE_Cmd_wr32(s_pHalContext, DISPLAY());
		EVE_CoCmd_swap(s_pHalContext);
		/* Download the commands into fifo */
		EVE_Cmd_waitFlush(s_pHalContext);
		t++;
		/* Wait till coprocessor completes the operation
		TBD - for maximum throughput we can check for only the leftout space in fifo and cotinue constructing the display lists */
		EVE_Cmd_waitFlush(s_pHalContext);

		//rate count increment logic
		pLARate->IttrCount++;
	}
}

/* Lift demo application demonstrates background animation and foreground digits and arrow direction in portrait orientation */
void LiftApp_Portrait() {
	/* Download the raw data of custom fonts into memory */
	int16_t BMoffsetx, BMoffsety, BHt = 156, BWd = 80, BSt = 80, Bfmt = L8, BArrowHt = 85, BArrowWd = 80, BArrowSt = 80, BArrowfmt = L8;
	int16_t NumBallsRange = 6, NumBallsEach = 10, RandomVal = 16;
#ifdef FT93X_PLATFORM
	NumBallsRange = 3;
	NumBallsEach = 5;
#endif
	int32_t Baddr0, Baddr1, Baddr2, Baddr3, i, SzInc = 16, SzFlag = 0;
	uint8_t fontr = 255, fontg = 255, fontb = 255, minute_temp, day_temp;
	S_LiftAppRate_t *pLARate;
	S_LiftAppTrasParams_t *pLATParams;
#ifdef FT93X_PLATFORM
	S_LiftAppBallsLinear_t S_LiftBallsArray[2 * 10], *pLiftBalls = NULL;//as of now 80 balls are been plotted
#else
	S_LiftAppBallsLinear_t S_LiftBallsArray[8 * 10], *pLiftBalls = NULL;//as of now 80 balls are been plotted
#endif
	App_GraphicsMatrix_t S_GPUMatrix;
	App_PostProcess_Transform_t S_GPUTrasMatrix;
	float temptransx, temptransy, running_rate;
	S_LiftAppCtxt_t S_LACtxt;

#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	_localtime st, lt;
	static uint32_t  counter, time_curr, tt, count_t;
	st.wHour = 14;
	st.wMinute = 26;
	st.wDay = 14;
	lt.wDayOfWeek = 3;
	st.wYear = 2017;
	st.wMilliseconds = 0;
	st.wSecond = 0;
	st.wMonth = 11;
#else
	SYSTEMTIME st, lt;
#endif
	uint16_t hour, hour_st, hour_nd, min, min_st, min_nd, sec, year, month, day, year_st_nd_dig, year_st_dig, year_nd_dig, year_rd_frth_dig, year_rd_dig, year_frth_dig;
	uint16_t day_st, day_nd;
	char8_t *day_of_week = " Sun, ", nd_line[100];
	char8_t text_run_disp[] = "The running text is displayed here.";
	char8_t *hour_st_str, *hour_nd_str, *min_st_str, *min_nd_str, *day_st_str, *day_nd_str, *year_st_str, *year_nd_str, *year_rd_str, *year_frth_str;
	char8_t* month_of_year;
	uint32_t stringlen, FontTableAddress, k, j, l, stringlen_week, stringlen_day, stringlen_text_run_disp, stringlen_st;
	int32_t FontWid = 0;
#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	float tttt;
#endif
	uint8_t *pbuff;
	int32_t FileLen = 0;
	Gpu_Fonts_t Display_fontstruct;
	float t = 0;
	uint16_t m;

	nd_line[0] = '0';

	/* Initial setup code to setup all the required bitmap handles globally */
	App_Set_DlBuffer_Index(0);
	pLARate = &S_LACtxt.SLARate;
	pLATParams = &S_LACtxt.SLATransPrms;

	//initialize all the rate parameters
	pLARate->CurrTime = 0;
	pLARate->IttrCount = 0;

	/* Initialize all the transition parameters - all the below are in terms of basic units of rate
	either they can be based on itterations or based on time giffies */
	pLATParams->FloorNumChangeRate = 64;
	pLATParams->MaxFloorNum = 90;
	pLATParams->MinFloorNum = 70;
	pLATParams->ResizeRate = 32;
	pLATParams->ResizeDimMax = 2 * 256;
	pLATParams->ResizeDimMin = 1 * 256;
	pLATParams->FloorNumStagnantRate = 180;

	/* Initialization of lift context parameters */
	S_LACtxt.ArrowDir = LIFTAPP_DIR_DOWN;//going down direction
	S_LACtxt.CurrFloorNum = 87;//current floor number to start with
	S_LACtxt.NextFloorNum = 80;//destination floor number as of now
	S_LACtxt.CurrArrowResizeRate = pLATParams->ResizeRate;
	S_LACtxt.CurrFloorNumResizeRate = pLATParams->ResizeRate;
	S_LACtxt.CurrFloorNumStagnantRate = 0;
	S_LACtxt.CurrFloorNumChangeRate = S_LACtxt.SLATransPrms.FloorNumChangeRate;
	S_LACtxt.AudioPlaying = 0;
	S_LACtxt.Orientation = 0;

	EVE_CoCmd_dlStart(s_pHalContext);

	EVE_Cmd_wr32(s_pHalContext, CLEAR_COLOR_RGB(255, 255, 255));
	EVE_Cmd_wr32(s_pHalContext, CLEAR(1, 1, 1)); // clear screen

	EVE_Cmd_wr32(s_pHalContext, BEGIN(BITMAPS));

	/* load the bitmap raw data */
	Baddr0 = RAM_G;
#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\font.raw", RAM_G, LOAD);
#else
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\font.raw", RAM_G, LOAD);
#endif
	EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(0));//handle 0 is used for all the characters
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(Baddr0));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_LAYOUT(Bfmt, BSt, BHt));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(BILINEAR, BORDER, BORDER, BHt * 2, BHt * 2));//make sure whole bitmap is displayed after rotation - as height is greater than width

	Baddr1 = ((Baddr0 + BSt*BHt * 11 + 15)&~15);

#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\arr.raw", Baddr1, LOAD);
#else
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\arr.raw", Baddr1, LOAD);
#endif
	EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(1));//bitmap handle 1 is used for arrow
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(Baddr1));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_LAYOUT(BArrowfmt, BArrowSt, BArrowHt));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(BILINEAR, BORDER, BORDER, BArrowHt * 2, BArrowHt * 2));//make sure whole bitmap is displayed after rotation - as height is greater than width

	Baddr2 = Baddr1 + 80 * 85;

#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs6.raw", Baddr2, LOAD);
#else
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs6.raw", Baddr2, LOAD);
#endif
	EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(2));//bitmap handle 2 is used for background balls
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(Baddr2));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_LAYOUT(L8, 60, 55));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(NEAREST, BORDER, BORDER, 60, 55));
	Baddr2 += 60 * 55;

#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs5.raw", Baddr2, LOAD);
#else
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs5.raw", Baddr2, LOAD);
#endif
	EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(3));//bitmap handle 2 is used for background balls
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(Baddr2));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_LAYOUT(L8, 50, 46));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(NEAREST, BORDER, BORDER, 50, 46));
	Baddr2 += 50 * 46;

#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs4.raw", Baddr2, LOAD);
#else
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs4.raw", Baddr2, LOAD);
#endif
	EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(4));//bitmap handle 2 is used for background balls
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(Baddr2));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_LAYOUT(L8, 40, 37));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(NEAREST, BORDER, BORDER, 40, 37));
	Baddr2 += 40 * 37;

#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs3.raw", Baddr2, LOAD);
#else
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs3.raw", Baddr2, LOAD);
#endif
	EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(5));//bitmap handle 2 is used for background balls
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(Baddr2));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_LAYOUT(L8, 30, 27));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(NEAREST, BORDER, BORDER, 30, 27));
	Baddr2 += 30 * 27;

#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs2.raw", Baddr2, LOAD);
#else
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs2.raw", Baddr2, LOAD);
#endif
	EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(6));//bitmap handle 2 is used for background balls
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(Baddr2));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_LAYOUT(L8, 20, 18));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(NEAREST, BORDER, BORDER, 20, 18));
	Baddr2 += 20 * 18;

#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs1.raw", Baddr2, LOAD);
#else
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\bs1.raw", Baddr2, LOAD);
#endif
	EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(7));//bitmap handle 2 is used for background balls
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(Baddr2));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_LAYOUT(L8, 10, 10));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(NEAREST, BORDER, BORDER, 10, 10));

	Baddr2 += 10 * 10;
#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\logo.raw", Baddr2, LOAD);
#else
	Gpu_Hal_LoadImageToMemory(s_pHalContext, TEST_DIR "\\logo.raw", Baddr2, LOAD);
#endif
	EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(11));//handle 11 is used for logo
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(Baddr2));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_LAYOUT(ARGB4, 99 * 2, 30));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(BILINEAR, BORDER, BORDER, 119, 123));//make sure whole bitmap is displayed after rotation - as height is greater than width
	Baddr2 += 99 * 2 * 30;
	// Read the font address from 0xFFFFC location 
	FontTableAddress = EVE_Hal_rd32(s_pHalContext, 0xFFFFC);

	App_Set_CmdBuffer_Index(0);

	/* Download the commands into fifo */
	EVE_Cmd_waitFlush(s_pHalContext);

	/* Wait till coprocessor completes the operation */
	EVE_Cmd_waitFlush(s_pHalContext);

	EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(8));
	EVE_Cmd_wr32(s_pHalContext, BITMAP_LAYOUT(L4, 9, 25));
#ifdef FT81X_ENABLE
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(0x2E799C));
#else
	EVE_Cmd_wr32(s_pHalContext, BITMAP_SOURCE(950172));
#endif

	EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(NEAREST, BORDER, BORDER, 50, 50));

	Baddr2 += 10 * 10;

	Baddr2 = ((Baddr2 + 7)&~7);//audio engine's requirement

	EVE_Cmd_wr32(s_pHalContext, DISPLAY());
	/* Download the DL into DL RAM */
	App_Flush_DL_Buffer(s_pHalContext);

	/* Do a swap */
	GPU_DLSwap(s_pHalContext, DLSWAP_FRAME);
	EVE_sleep(30);

	/* compute the random values at the starting */
	pLiftBalls = S_LiftBallsArray;
	for (i = 0; i < (NumBallsRange*NumBallsEach); i++) {
		//always start from the right and move towards left
		pLiftBalls->xOffset = random(s_pHalContext->Width * 16);
		pLiftBalls->yOffset = random(s_pHalContext->Height * 16);
		pLiftBalls->dx = -1 * random(RandomVal * 8);//always -ve
		pLiftBalls->dy = random(RandomVal * 8) - RandomVal * 4;
		pLiftBalls++;
	}

	while (1) {
		/* Logic of user touch - change background or skin wrt use touch */
		/* Logic of transition - change of floor numbers and direction */
		LiftApp_FTransition(&S_LACtxt, Baddr2);
		EVE_CoCmd_dlStart(s_pHalContext);
		EVE_Cmd_wr32(s_pHalContext, CLEAR_COLOR_RGB(255, 255, 255));
		EVE_Cmd_wr32(s_pHalContext, CLEAR(1, 1, 1)); // clear screen
		EVE_Cmd_wr32(s_pHalContext, COLOR_RGB(255, 255, 255));
		EVE_Cmd_wr32(s_pHalContext, SAVE_CONTEXT());
		/* Background gradient */
		EVE_CoCmd_gradient(s_pHalContext, 0, 0, 0x66B4E8, s_pHalContext->Width, 0, 0x132B3B);

		/* Draw background bitmaps */
		EVE_Cmd_wr32(s_pHalContext, COLOR_RGB(0, 0, 0));
		pLiftBalls = S_LiftBallsArray;
		EVE_Cmd_wr32(s_pHalContext, BEGIN(BITMAPS));

		EVE_Cmd_wr32(s_pHalContext, COLOR_A(64));
		EVE_Cmd_wr32(s_pHalContext, COLOR_RGB(255, 255, 255));
		for (i = 0; i < (NumBallsRange*NumBallsEach); i++) {
			if (0 == i%NumBallsEach) {
				EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(2 + (i / NumBallsEach)));
			}
			if (((pLiftBalls->xOffset >((s_pHalContext->Width + 60) * 16)) || (pLiftBalls->yOffset > ((s_pHalContext->Height + 60) * 16))) ||
				((pLiftBalls->xOffset < (-60 * 16)) || (pLiftBalls->yOffset < (-60 * 16)))) {
				pLiftBalls->xOffset = s_pHalContext->Width * 16 + random(80 * 16);
				pLiftBalls->yOffset = random(s_pHalContext->Height * 16);
				pLiftBalls->dx = -1 * random(RandomVal * 8);
				pLiftBalls->dy = random(RandomVal * 8) - RandomVal * 4;

			}
						EVE_Cmd_wr32(s_pHalContext, VERTEX2F(pLiftBalls->xOffset, pLiftBalls->yOffset));
			pLiftBalls->xOffset += pLiftBalls->dx;
			pLiftBalls->yOffset += pLiftBalls->dy;
			pLiftBalls++;
		}
		EVE_Cmd_wr32(s_pHalContext, END());
		EVE_Cmd_wr32(s_pHalContext, ALPHA_FUNC(ALWAYS, 0));
		EVE_Cmd_wr32(s_pHalContext, COLOR_A(255));

		if (LIFTAPP_DIR_NONE != S_LACtxt.ArrowDir)//do not display the arrow in case of no direction, meaning stagnant
		{
			//calculation of size value based on the rate
			//the bitmaps are scaled from original resolution till 2 times the resolution on both x and y axis
			SzInc = 16 + (S_LACtxt.SLATransPrms.ResizeRate / 2 - abs(S_LACtxt.CurrArrowResizeRate%S_LACtxt.SLATransPrms.ResizeRate - S_LACtxt.SLATransPrms.ResizeRate / 2));
			EVE_Cmd_wr32(s_pHalContext, COLOR_RGB(fontr, fontg, fontb));
			/* Draw the arrow first */
			EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(1));
			EVE_Cmd_wr32(s_pHalContext, BEGIN(BITMAPS)); // start drawing bitmaps
			BMoffsetx = (BArrowWd - (BArrowWd*SzInc / 32));
			BMoffsety = ((s_pHalContext->Height / 2) - (BArrowHt*SzInc / 32));

			/* perform inplace flip and scale of bitmap in case of direction is up */
			App_TrsMtrxLoadIdentity(&S_GPUMatrix);
			App_TrsMtrxTranslate(&S_GPUMatrix, 80 / 2.0, 85 / 2.0, &temptransx, &temptransy);
			App_TrsMtrxScale(&S_GPUMatrix, (SzInc / 16.0), (SzInc / 16.0));
			App_TrsMtrxRotate(&S_GPUMatrix, 90);
			if (LIFTAPP_DIR_UP == S_LACtxt.ArrowDir) {
				App_TrsMtrxFlip(&S_GPUMatrix, APP_GRAPHICS_FLIP_RIGHT);
			}

			App_TrsMtrxTranslate(&S_GPUMatrix, (-80 * SzInc) / 32.0, (-85 * SzInc) / 32.0, &temptransx, &temptransy);
			App_UpdateTrsMtrx(&S_GPUMatrix, &S_GPUTrasMatrix);
			EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_A(S_GPUTrasMatrix.Transforma));
			EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_B(S_GPUTrasMatrix.Transformb));
			EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_C(S_GPUTrasMatrix.Transformc));
			EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_D(S_GPUTrasMatrix.Transformd));
			EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_E(S_GPUTrasMatrix.Transforme));
			EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_F(S_GPUTrasMatrix.Transformf));
#ifdef DISPLAY_RESOLUTION_WVGA
			LiftAppComputeBitmap_Single(G_LiftAppFontArrayArrow, 0, SzInc * 16, BArrowWd * 2, (s_pHalContext->Height / 2));

#elif defined DISPLAY_RESOLUTION_HVGA_PORTRAIT
			LiftAppComputeBitmap_Single(G_LiftAppFontArrayArrow, 0, SzInc * 16, BArrowWd*1.8, (s_pHalContext->Height / 4));
#else
			LiftAppComputeBitmap_Single(G_LiftAppFontArrayArrow, 0, SzInc * 16, BArrowWd, (s_pHalContext->Height / 2));
#endif
			EVE_CoCmd_loadIdentity(s_pHalContext);
			EVE_CoCmd_setMatrix(s_pHalContext);
		}

		/* algorithm for animation - floor numbers will change in dimensions when stagnant at a perticular floor */
		/* arrow will change in case of movement of lift */
		/* display the bitmap with increased size */
		SzInc = 16 + (S_LACtxt.SLATransPrms.ResizeRate / 2 - abs(S_LACtxt.CurrFloorNumResizeRate%S_LACtxt.SLATransPrms.ResizeRate - S_LACtxt.SLATransPrms.ResizeRate / 2));
		BMoffsetx = s_pHalContext->Width - BWd * 2 - (BWd*SzInc / 32);
		BMoffsety = ((s_pHalContext->Height / 2) - (BHt*SzInc / 32));

		/* calculate the resolution change based on the number of characters used as well as */
		EVE_Cmd_wr32(s_pHalContext, COLOR_RGB(fontr, fontg, fontb));
		/* perform inplace flip and scale of bitmap in case of direction is up */
		App_TrsMtrxLoadIdentity(&S_GPUMatrix);
		App_TrsMtrxTranslate(&S_GPUMatrix, BWd / 2.0, BHt / 2.0, &temptransx, &temptransy);
		App_TrsMtrxScale(&S_GPUMatrix, (SzInc / 16.0), (SzInc / 16.0));
		App_TrsMtrxRotate(&S_GPUMatrix, 90);
		App_TrsMtrxTranslate(&S_GPUMatrix, (-BHt*SzInc) / 32.0, (-BWd*SzInc) / 32.0, &temptransx, &temptransy);
		App_UpdateTrsMtrx(&S_GPUMatrix, &S_GPUTrasMatrix);
		EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_A(S_GPUTrasMatrix.Transforma));
		EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_B(S_GPUTrasMatrix.Transformb));
		EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_C(S_GPUTrasMatrix.Transformc));
		EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_D(S_GPUTrasMatrix.Transformd));
		EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_E(S_GPUTrasMatrix.Transforme));
		EVE_Cmd_wr32(s_pHalContext, BITMAP_TRANSFORM_F(S_GPUTrasMatrix.Transformf));

		EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(0));
		EVE_Cmd_wr32(s_pHalContext, BEGIN(BITMAPS)); // start drawing bitmaps

        //adjust the  position of num
#ifdef DISPLAY_RESOLUTION_WVGA
		LiftAppComputeBitmapRowRotate(G_LiftAppFontArrayNumbers, S_LACtxt.CurrFloorNum, 0, SzInc * 16, s_pHalContext->Width - BHt - 100, (s_pHalContext->Height / 2));

#elif defined DISPLAY_RESOLUTION_HVGA_PORTRAIT
		LiftAppComputeBitmapRowRotate(G_LiftAppFontArrayNumbers, S_LACtxt.CurrFloorNum, 0, SzInc * 16, s_pHalContext->Width - BHt, (s_pHalContext->Height * 3 / 4 - 50));
#elif defined DISPLAY_RESOLUTION_QVGA
		LiftAppComputeBitmapRowRotate(G_LiftAppFontArrayNumbers, S_LACtxt.CurrFloorNum, 0, SzInc * 16, s_pHalContext->Width - BHt, (s_pHalContext->Height * 3 / 4 - 50));
#else
		LiftAppComputeBitmapRowRotate(G_LiftAppFontArrayNumbers, S_LACtxt.CurrFloorNum, 0, SzInc * 16, s_pHalContext->Width - BHt, (s_pHalContext->Height / 2));
#endif
#if !defined(FT9XX_PLATFORM) && !defined(RP2040_PLATFORM) 
		GetSystemTime(&st);
		GetLocalTime(&lt);

#else

		curr_rtc_clock++;
		time_curr = curr_rtc_clock % 32;
		t = curr_rtc_clock / 32 * 1000 % 1000;
		if (time_curr < tt) {
			count_t++;
		}

		lt.wSecond = curr_rtc_clock / 32 % 60;
		lt.wMinute = (curr_rtc_clock / 32 / 60 + st.wMinute) % 60;

		if (lt.wMinute < minute_temp) {
			st.wHour++;
		}
		minute_temp = lt.wMinute;
		lt.wHour = (curr_rtc_clock / 32 / 3600 + st.wHour) % 12;

		if (lt.wDay < day_temp) {
			st.wDay++;
		}
		lt.wDay = (curr_rtc_clock / 32 / 3600 / 24 + st.wDay) % 30;
		day_temp = lt.wDay;
		lt.wMonth = st.wMonth;
		lt.wYear = 2017;

#endif
		hour = (uint16_t)lt.wHour;
		min = (uint16_t)lt.wMinute;
		year = (uint16_t)lt.wYear;
		day = (uint16_t)lt.wDay;
#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
		lt.wSecond++;
#endif
		if (lt.wMonth == 1) {
			month_of_year = " January";
		}
		else if (lt.wMonth == 2) {
			month_of_year = " February";
		}
		else if (lt.wMonth == 3) {
			month_of_year = " March ";
		}
		else if (lt.wMonth == 4) {
			month_of_year = " April ";
		}
		else if (lt.wMonth == 5) {
			month_of_year = " May ";
		}
		else if (lt.wMonth == 6) {
			month_of_year = " June ";
		}
		else if (lt.wMonth == 7) {
			month_of_year = " July ";
		}
		else if (lt.wMonth == 8) {
			month_of_year = " August ";
		}
		else if (lt.wMonth == 9) {
			month_of_year = " September";
		}
		else if (lt.wMonth == 10) {
			month_of_year = " October ";
		}
		else if (lt.wMonth == 11) {
			month_of_year = " November";
		}
		else if (lt.wMonth == 12) {
			month_of_year = " December";
		}
		if (lt.wDayOfWeek == 0) {
			day_of_week = "Sun,";
		}
		else if (lt.wDayOfWeek == 1) {
			day_of_week = "Mon,";
		}
		else if (lt.wDayOfWeek == 2) {
			day_of_week = "Tue,";
		}
		else if (lt.wDayOfWeek == 3) {
			day_of_week = "Wed,";
		}
		else if (lt.wDayOfWeek == 4) {
			day_of_week = "Thur,";
		}
		else if (lt.wDayOfWeek == 5) {
			day_of_week = "Fri,";
		}
		else if (lt.wDayOfWeek == 6) {
			day_of_week = "Sat,";
		}

		EVE_Cmd_wr32(s_pHalContext, BEGIN(BITMAPS));
		BMoffsetx = ((s_pHalContext->Width / 2) + 170);
		BMoffsety = ((s_pHalContext->Height / 2) + 105);

#ifdef DISPLAY_RESOLUTION_WVGA//adjust for time display
		BMoffsetx = (700);
		BMoffsety = (430);

#endif
#if defined(DISPLAY_RESOLUTION_HVGA_PORTRAIT) 
		BMoffsetx = ((s_pHalContext->Width / 2) + 100);
		BMoffsety = ((s_pHalContext->Height / 2) + 180);
#elif defined(DISPLAY_RESOLUTION_QVGA)
		BMoffsetx = ((s_pHalContext->Width / 2) + 100);
		BMoffsety = ((s_pHalContext->Height / 2) + 180);
#endif
		EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(28));
		EVE_Cmd_wr32(s_pHalContext, BITMAP_SIZE(NEAREST, BORDER, BORDER, 25, 25));

		EVE_CoCmd_loadIdentity(s_pHalContext);
		EVE_CoCmd_translate(s_pHalContext, 18 * 65536 / 2, 25 * 65536 / 2);
		EVE_CoCmd_rotate(s_pHalContext, -90 * 65536 / 360);
		EVE_CoCmd_translate(s_pHalContext, -25 * 65536 / 2, -18 * 65536 / 2);
		EVE_CoCmd_setMatrix(s_pHalContext);

		if (hour > 9) {
			hour_st = (hour / 10) + '0';
			hour_nd = (hour % 10) + '0';
			hour_st_str = &hour_st;
			hour_nd_str = &hour_nd;
			strcat(hour_st_str, hour_nd_str);
		}
		else {
			hour = hour + '0';
			hour_st_str = &hour;
			strcpy(hour_st_str, hour_st_str);
		}

		strcat(hour_st_str, ":");

		min_st = min / 10 + '0';
		min_nd = min % 10 + '0';
		min_st_str = &min_st;
		min_nd_str = &min_nd;
		strcat(min_st_str, min_nd_str);
		strcat(hour_st_str, min_st_str);
		stringlen_st = strlen(hour_st_str);

#ifdef DISPLAY_RESOLUTION_WVGA
		font_display(BMoffsetx, BMoffsety, stringlen_st, hour_st_str, 0);
#else
		font_display(BMoffsetx, BMoffsety, stringlen_st, hour_st_str, 0);
#endif

		BMoffsetx = ((s_pHalContext->Width / 2) + 190);
		BMoffsety = ((s_pHalContext->Height / 2) + 105);

#ifdef DISPLAY_RESOLUTION_WVGA
		BMoffsety = (370);
		BMoffsetx = 700;
#endif
#if defined( DISPLAY_RESOLUTION_HVGA_PORTRAIT)
		BMoffsetx = ((s_pHalContext->Width / 2) + 100);
		BMoffsety = ((s_pHalContext->Height / 2) + 80);
#elif defined(DISPLAY_RESOLUTION_QVGA)
		BMoffsetx = ((s_pHalContext->Width / 2) + 100);
		BMoffsety = ((s_pHalContext->Height / 2) + 80);
#endif
		strcpy(&nd_line, day_of_week);

		day_st = (day / 10) + '0';
		day_nd = (day % 10) + '0';
		day_st_str = &day_st;
		day_nd_str = &day_nd;

		strcat(day_st_str, day_nd_str);

		strcat(&nd_line, day_st_str);

		strcat(&nd_line, month_of_year);

#ifndef DISPLAY_RESOLUTION_QVGA
		year_st_nd_dig = year / 100;
		year_st_dig = (year_st_nd_dig / 10) + '0';
		year_nd_dig = year_st_nd_dig % 10 + '0';
		year_rd_frth_dig = year % 100;
		year_rd_dig = (year_rd_frth_dig / 10) + '0';
		year_frth_dig = (year_rd_frth_dig % 10) + '0';

		year_st_str = &year_st_dig;
		year_nd_str = &year_nd_dig;
		year_rd_str = &year_rd_dig;
		year_frth_str = &year_frth_dig;

		strcat(year_st_str, year_nd_str);
		strcat(&nd_line, year_st_str);
		strcat(year_rd_str, year_frth_str);
		strcat(&nd_line, year_rd_str);
#endif
		stringlen_st = strlen(nd_line);

		font_display(BMoffsetx, BMoffsety, stringlen_st, nd_line, 0);

		BMoffsetx = ((s_pHalContext->Width / 2) + 210);
		BMoffsety = ((s_pHalContext->Height / 2) + 130);
#ifdef DISPLAY_RESOLUTION_WVGA
		BMoffsetx = (750);
#endif
#if defined( DISPLAY_RESOLUTION_HVGA_PORTRAIT)
		BMoffsetx = ((s_pHalContext->Width / 2) + 115);
#elif defined( DISPLAY_RESOLUTION_QVGA)
		BMoffsetx = ((s_pHalContext->Width / 2) + 115);
#endif
		stringlen_text_run_disp = strlen(text_run_disp);

#if defined(FT9XX_PLATFORM) || defined(RP2040_PLATFORM)
		if (t < 200) {
			t++;
			tttt++;
		}
		else {
			t = 0;
		}
		BMoffsety = linear(0, 480, tttt, 200);
#else
		if (t < 200)
			t++;
		BMoffsety = linear(0, 272, t, 200);

#endif
		font_display(BMoffsetx, BMoffsety, stringlen_text_run_disp, text_run_disp, 0);

		EVE_Cmd_wr32(s_pHalContext, RESTORE_CONTEXT());

		/* Rotate Logo bitmap 270 degree */
		EVE_CoCmd_loadIdentity(s_pHalContext);
		EVE_CoCmd_translate(s_pHalContext, 59 * 65536, 61 * 65536);
		EVE_CoCmd_rotate(s_pHalContext, 270 * 65536 / 360);
		EVE_CoCmd_translate(s_pHalContext, -59 * 65536, -61 * 65536);
		EVE_CoCmd_setMatrix(s_pHalContext);

		EVE_Cmd_wr32(s_pHalContext, BEGIN(BITMAPS));
		EVE_Cmd_wr32(s_pHalContext, BITMAP_HANDLE(11));

#ifdef DISPLAY_RESOLUTION_WVGA
		EVE_Cmd_wr32(s_pHalContext, VERTEX2F(10 * 16, (s_pHalContext->Height - 130) * 16));

#elif defined DISPLAY_RESOLUTION_HVGA_PORTRAIT
		EVE_Cmd_wr32(s_pHalContext, VERTEX2F(10 * 16, 20 * 16));
#elif defined DISPLAY_RESOLUTION_WQVGA
		EVE_Cmd_wr32(s_pHalContext, VERTEX2F(10 * 16, (s_pHalContext->Height - 130) * 16));
#else
		EVE_Cmd_wr32(s_pHalContext, VERTEX2F(10 * 16, (s_pHalContext->Height - 130) * 16));
#endif
		EVE_Cmd_wr32(s_pHalContext, DISPLAY());
		EVE_CoCmd_swap(s_pHalContext);
		t++;
		/* Wait till coprocessor completes the operation */
		EVE_Cmd_waitFlush(s_pHalContext);
		//rate count increment - 
		pLARate->IttrCount++;
	}
}

void DemoLift() {
#ifdef ORIENTATION_PORTRAIT
	LiftApp_Portrait();
#endif

#ifdef ORIENTATION_LANDSCAPE
	LiftApp_Landscape();
#endif	
}
